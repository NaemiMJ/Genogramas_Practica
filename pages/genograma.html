<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Genograma</title>
  <link rel="stylesheet" href="../style/style_geno.css">
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
</head>
<body>
  <h1>Genograma</h1>
  <button id="btnGuardarDB" class="btn-save">游 Guardar Cambios</button>

  <div class="form-wrapper" id="formPaciente">
    <h3>Agregar paciente</h3>
    <label>Nombre: <input type="text" id="nombre" /></label>
    <label>Apellido: <input type="text" id="apellido" /></label>
    <label>Edad: <input type="number" id="edad" min="0" /></label>
    <label>Sexo:
      <select id="sexo">
        <option value="M">Masculino</option>
        <option value="F">Femenino</option>
      </select>
    </label>
    <div style="margin-top:8px">
      <button id="agregarPaciente">Agregar paciente</button>
    </div>
  </div>

  <div class="genograma-container">
    <div id="conexiones"></div>

    <div class="genograma">
      <div class="fila padres" id="padres">
        <div class="parent-slot" id="padre-slot"></div>
        <div class="parent-slot" id="madre-slot"></div>
      </div>

      <div class="fila middle-row" id="middle">
        <div class="pareja-slot" id="partner-left-slot"></div>

        <div class="center-block" id="center-block">
          <div class="hermanos left" id="hermanos-left"></div>
          <div class="paciente-slot" id="paciente-slot"></div>
          <div class="hermanos right" id="hermanos-right"></div>
        </div>

        <div class="pareja-slot" id="partner-right-slot"></div>
      </div>

      <div class="fila hijos" id="hijos"></div>
    </div>
  </div>

  <div id="formFamiliar" class="modal oculto" role="dialog" aria-hidden="true">
    <div class="modal-inner">
      <h4>Agregar familiar</h4>
      <label>Nombre: <input type="text" id="famNombre" /></label>
      <label>Apellido: <input type="text" id="famApellido" /></label>
      <label>Edad: <input type="number" id="famEdad" min="0" /></label>
      <label>Sexo:
        <select id="famSexo">
          <option value="M">Masculino</option>
          <option value="F">Femenino</option>
        </select>
      </label>
      <label>Rol:
        <select id="famRol">
          <option value="padre">Padre/Madre</option>
          <option value="pareja">Pareja</option>
          <option value="hermano">Hermano/a</option>
          <option value="hijo">Hijo/a</option>
        </select>
      </label>
      
      <div id="divTipoHijo" style="display:none; margin-top:8px;">
        <label>Tipo de Hijo:
          <select id="famTipoHijo" style="width:100%">
            <option value="biologico">Biol칩gico (Normal)</option>
            <option value="adoptado">Adoptado (L칤nea Punteada)</option>
            <option value="mellizo">Mellizo (Dizig칩tico)</option>
            <option value="gemelo">Gemelo (Monocig칩tico/Id칠ntico)</option>
          </select>
        </label>
      </div>

      <label>Salud / Problemas:
        <select id="famSalud" style="width:100%">
          <option value="ninguno">Ninguno</option>
          <option value="abuso">Abuso Alcohol/Drogas</option>
          <option value="ingreso">Ingreso / Recuperaci칩n</option> <option value="sospecha">Sospecha de Abuso</option>
          <option value="mental">Prob. Mentales / Psicol칩gicos</option>
          <option value="ambos">Comorbilidad (Abuso + Mental)</option>
        </select>
      </label>
      <label>Estado Vital:
        <select id="famEstado" style="width:100%">
          <option value="vivo">Vivo</option>
          <option value="fallecido">Fallecido</option>
          <option value="embarazo">Embarazo</option>
          <option value="neonato_x">Muerte al nacer</option>
          <option value="aborto_esp">Aborto Espont치neo</option>
          <option value="aborto_prov">Aborto Provocado</option>
        </select>
      </label>
      <label style="display:inline-flex; align-items:center; gap:5px; margin-top:5px;">
        <input type="checkbox" id="famLgtb" /> 
        LGTBIQ+
      </label>
      <div id="lblDivorcio" style="display:none; margin-top:8px;">
        <label>Estado de la Relaci칩n:
          <select id="famTipoRelacion" style="width:100%">
            <option value="normal">Relaci칩n Vigente (Matrimonio)</option>
            <option value="de_hecho">Pareja de hecho / Amante</option>
            <option value="separacion">Separaci칩n</option>
            <option value="divorcio">Divorcio</option>
            <option value="reconciliacion">Reconciliaci칩n tras Divorcio</option> </select>
        </label>
      </div>
      <div id="bloqueFechasRelacion" style="display:none; margin-top:8px; padding:10px; background:#f0f0f0; border-radius:4px;">
        <label style="font-weight:bold;">Cronolog칤a de la Relaci칩n:</label>
        <div style="display:flex; gap:10px; margin-top:5px;">
          <label style="flex:1;">A침o Inicio: 
            <input type="number" id="relAnioInicio" placeholder="Ej: 1990" min="1900" max="2030" style="width:100%">
          </label>
          <label style="flex:1;">A침o Fin (si aplica): 
            <input type="number" id="relAnioFin" placeholder="Ej: 2005" min="1900" max="2030" style="width:100%">
          </label>
        </div>
        <small style="color:#666;">Necesario para ordenar relaciones m칰ltiples.</small>
      </div>

      <div class="modal-actions" style="margin-top:8px;">
        <button id="guardarFamiliarBtn">Agregar</button>
        <button type="button" onclick="cerrarFormFamiliar()">Cancelar</button>
      </div>
    </div>
  </div>

  <div id="menuAcciones" class="menu-acciones oculto">
    <button id="menuAgregar">Agregar familiar</button>
    <button id="menuEliminar">Eliminar</button>
    <button onclick="cerrarMenu()">Cerrar</button>
  </div>

<script>
/* ========== Modelo de datos ========== */
function uid(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,8); }

let patient = null;
let parents = { father: null, mother: null };
let partners = []; // Ahora es una lista vac칤a
let siblings = [];
let children = [];
let seleccionado = null;

/* ========== Selectores DOM ========== */
const padreSlot = document.getElementById('padre-slot');
const madreSlot = document.getElementById('madre-slot');
const partnerLeftSlot = document.getElementById('partner-left-slot');
const partnerRightSlot = document.getElementById('partner-right-slot');
const hermanosLeft = document.getElementById('hermanos-left');
const hermanosRight = document.getElementById('hermanos-right');
const pacienteSlot = document.getElementById('paciente-slot');
const hijosSlot = document.getElementById('hijos');
const genogramaContainer = document.querySelector('.genograma-container');
const middleRow = document.getElementById('middle'); 
const hijosRow = document.getElementById('hijos'); 

const formPaciente = document.getElementById('formPaciente');
const agregarPacienteBtn = document.getElementById('agregarPaciente');
const menu = document.getElementById('menuAcciones');
const menuAgregarBtn = document.getElementById('menuAgregar');
const menuEliminarBtn = document.getElementById('menuEliminar');
const formFamiliar = document.getElementById('formFamiliar');
const guardarFamiliarBtn = document.getElementById('guardarFamiliarBtn');

const famRolSelect = document.getElementById('famRol');

/* --- MODIFICAR: Funci칩n para mostrar/ocultar opciones de PAREJA --- */
const divRelacion = document.getElementById('lblDivorcio');
const tipoRelacionInput = document.getElementById('famTipoRelacion');
// NUEVO SELECTOR:
const bloqueFechasRelacion = document.getElementById('bloqueFechasRelacion');

function toggleDivorcioOption() {
  const esPareja = (famRolSelect.value === 'pareja');

  if (esPareja) {
    divRelacion.style.display = 'block';
    // NUEVO: Mostrar fechas
    bloqueFechasRelacion.style.display = 'block';
  } else {
    divRelacion.style.display = 'none';
    // NUEVO: Ocultar fechas y resetear
    bloqueFechasRelacion.style.display = 'none';
    tipoRelacionInput.value = 'normal';
    document.getElementById('relAnioInicio').value = '';
    document.getElementById('relAnioFin').value = '';
  }
}

// NUEVO: Listener unificado para cambios de ROL (Pareja y Tipo de Hijo)
famRolSelect.addEventListener('change', () => {
  // 1. L칩gica de Pareja
  toggleDivorcioOption();
  
  // 2. L칩gica de Estados (abortos, etc)
  filtrarOpcionesEstado();

  // 3. NUEVO: L칩gica para mostrar "Tipo de Hijo"
  const divTipoHijo = document.getElementById('divTipoHijo');
  const tipoHijoInput = document.getElementById('famTipoHijo');
  
  if (famRolSelect.value === 'hijo') {
    divTipoHijo.style.display = 'block';
  } else {
    divTipoHijo.style.display = 'none';
    tipoHijoInput.value = 'biologico'; // Reset por seguridad
  }
});


/* --- L칍GICA: FILTRAR ESTADOS SEG칔N ROL --- */
/* --- L칍GICA: FILTRAR ESTADOS SEG칔N ROL --- */
const famEstadoSelect = document.getElementById('famEstado');

function filtrarOpcionesEstado() {
  const rol = famRolSelect.value;
  // Estados que queremos que sean exclusivos para el rol 'hijo'
  const estadosInfantiles = ['embarazo', 'neonato_x', 'aborto_esp', 'aborto_prov'];
  
  for (let i = 0; i < famEstadoSelect.options.length; i++) {
    const opt = famEstadoSelect.options[i];
    
    // Si la opci칩n actual es una de las "infantiles"
    if (estadosInfantiles.includes(opt.value)) {
      // SOLO mostramos si el rol es exactamente 'hijo'
      if (rol === 'hijo') {
        opt.hidden = false; 
        opt.disabled = false; 
        opt.style.display = 'block';
      } else {
        // Para cualquier otro rol (padre, pareja, hermano), se oculta
        opt.hidden = true; 
        opt.disabled = true; 
        opt.style.display = 'none';
      }
    }
  }

  // Validaci칩n de seguridad:
  // Si el usuario ten칤a seleccionado "aborto" y cambia el rol a "Padre",
  // el valor quedar칤a inv치lido. Forzamos el cambio a "vivo".
  const valorActual = famEstadoSelect.value;
  if (estadosInfantiles.includes(valorActual) && rol !== 'hijo') {
    famEstadoSelect.value = 'vivo';
    // Llamamos a actualizarCampos para que habilite de nuevo drogas/lgtb si estaban bloqueados
    actualizarCamposPorEstado();
  }
}

/* --- A. L칍GICA DE BLOQUEO (Sin drogas/LGTB para fetos) --- */
function actualizarCamposPorEstado() {
  const estado = famEstadoSelect.value;
  const saludSelect = document.getElementById('famSalud');
  const lgtbCheck = document.getElementById('famLgtb');
  const estadosInfantiles = ['embarazo', 'neonato_x', 'aborto_esp', 'aborto_prov'];
  
  if (estadosInfantiles.includes(estado)) {
    saludSelect.value = 'ninguno';
    lgtbCheck.checked = false;
    saludSelect.disabled = true;
    lgtbCheck.disabled = true;
    saludSelect.parentElement.style.opacity = '0.5';
    lgtbCheck.parentElement.style.opacity = '0.5';
  } else {
    saludSelect.disabled = false;
    lgtbCheck.disabled = false;
    saludSelect.parentElement.style.opacity = '1';
    lgtbCheck.parentElement.style.opacity = '1';
  }
}

famEstadoSelect.addEventListener('change', actualizarCamposPorEstado);

/* ========== Utilidades ========== */
const getNum = v => { const n = parseInt(v); return Number.isFinite(n) ? n : null; };
function getCenterX(el) { const r = el.getBoundingClientRect(); return r.left + r.width / 2; }

// Funci칩n para ordenar un array de parejas cronol칩gicamente.
function ordenarParejasPorFecha(listaParejas, ordenDescendente = true) {
  return listaParejas.sort((a, b) => {
    // Usamos 0 como valor por defecto si no se introdujo a침o, para evitar errores
    const inicioA = a.relAnioInicio || 0;
    const inicioB = b.relAnioInicio || 0;

    if (ordenDescendente) {
        // Orden: M치s Reciente -> M치s Antiguo (Ej: 2020, 2010, 1990)
        // Esto se usa para las parejas que est치n "m치s cerca" del sujeto central.
        return inicioB - inicioA; 
    } else {
        // Orden: M치s Antiguo -> M치s Reciente (Ej: 1990, 2010, 2020)
        return inicioA - inicioB;
    }
  });
}

/* ========== Crear nodo persona ========== */
function crearNodo(persona) {
  const div = document.createElement('div');
  
  let clases = 'persona ' + (persona.sexo === 'M' ? 'hombre' : 'mujer');
  if (persona.esPaciente) clases += ' paciente';
  
  if (persona.estado === 'fallecido') clases += ' fallecido';
  else if (persona.estado === 'embarazo') clases += ' embarazo';
  else if (persona.estado === 'neonato_x') clases += ' neonato-x';
  else if (persona.estado === 'aborto_esp') clases += ' aborto-esp';
  else if (persona.estado === 'aborto_prov') clases += ' aborto-prov';

  if (persona.salud && persona.salud !== 'ninguno') clases += ' patron-' + persona.salud; 
  if (persona.lgtb) clases += ' lgtb'; 
  
  div.className = clases;
  div.dataset.id = persona.id;

  if (persona.lgtb) {
    const tri = document.createElement('div');
    tri.className = 'simbolo-lgtb';
    div.appendChild(tri);
  }

  const sinTexto = ['aborto_esp', 'aborto_prov']; 
  if (!sinTexto.includes(persona.estado)) {
    const nombre = document.createElement('div');
    nombre.className = 'nombre';
    nombre.textContent = persona.nombre + (persona.apellido ? (' ' + persona.apellido) : '');

    const edad = document.createElement('div');
    edad.className = 'edad';
    edad.textContent = persona.edad ? (persona.edad + ' a침os') : '';

    div.appendChild(nombre);
    div.appendChild(edad);
  }
  
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    seleccionado = persona;
    abrirMenu(e.pageX, e.pageY);
  });
  
  return div;
}

/* ========== Konva Config ========== */
let stage = null;
let layer = null;

/* ========== L칩gica de Alineaci칩n ========== */
function alinearGenograma() {
  middleRow.style.transform = '';
  hijosRow.style.transform = '';

  const fatherDom = padreSlot.querySelector('.persona');
  const motherDom = madreSlot.querySelector('.persona');
  const patientDom = pacienteSlot.querySelector('.persona');
  const partnerDom = partnerLeftSlot.querySelector('.persona') || partnerRightSlot.querySelector('.persona');
  
  const leftSibs = Array.from(hermanosLeft.querySelectorAll('.persona'));
  const rightSibs = Array.from(hermanosRight.querySelectorAll('.persona'));
  const allSiblingsNodes = [...leftSibs, patientDom, ...rightSibs].filter(Boolean);

  let shiftMiddle = 0;

  if ((fatherDom || motherDom) && allSiblingsNodes.length > 0) {
    let parentsCenter = 0;
    if (fatherDom && motherDom) {
      parentsCenter = (getCenterX(fatherDom) + getCenterX(motherDom)) / 2;
    } else {
      parentsCenter = getCenterX(fatherDom || motherDom);
    }

    const firstRect = allSiblingsNodes[0].getBoundingClientRect();
    const lastRect = allSiblingsNodes[allSiblingsNodes.length - 1].getBoundingClientRect();
    const childrenGroupCenter = (firstRect.left + lastRect.right) / 2;
    shiftMiddle = parentsCenter - childrenGroupCenter;
  }

  let shiftHijos = 0;
  const hijosNodes = Array.from(hijosSlot.querySelectorAll('.persona'));

  if (patientDom && hijosNodes.length > 0) {
    const patientVisualX = getCenterX(patientDom) + shiftMiddle;
    let marriageVisualCenter = patientVisualX;

    if (partnerDom) {
      const partnerVisualX = getCenterX(partnerDom) + shiftMiddle;
      marriageVisualCenter = (patientVisualX + partnerVisualX) / 2;
    }

    const firstChildRect = hijosNodes[0].getBoundingClientRect();
    const lastChildRect = hijosNodes[hijosNodes.length - 1].getBoundingClientRect();
    const childrenGroupCenter = (firstChildRect.left + lastChildRect.right) / 2;
    
    shiftHijos = marriageVisualCenter - childrenGroupCenter;
  }

  if (Math.abs(shiftMiddle) > 0.5) middleRow.style.transform = `translateX(${shiftMiddle}px)`;
  if (Math.abs(shiftHijos) > 0.5) hijosRow.style.transform = `translateX(${shiftHijos}px)`;
}

/* ========== Renderizar ========== */
function render() {
  padreSlot.innerHTML = ''; madreSlot.innerHTML = '';
  partnerLeftSlot.innerHTML = ''; partnerRightSlot.innerHTML = '';
  hermanosLeft.innerHTML = ''; hermanosRight.innerHTML = '';
  pacienteSlot.innerHTML = ''; hijosSlot.innerHTML = '';

  if (parents.father) padreSlot.appendChild(crearNodo(parents.father));
  if (parents.mother) madreSlot.appendChild(crearNodo(parents.mother));

  if (!patient) {
    siblings.sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0)).forEach(s => hermanosRight.appendChild(crearNodo(s)));
    requestAnimationFrame(dibujarConexiones);
    return;
  }

  const sortedSiblings = [...siblings].sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0));
  const pAge = getNum(patient.edad) || 0;
  let insertIndex = Math.floor(sortedSiblings.length / 2);
  const maxSibAge = sortedSiblings.length ? (getNum(sortedSiblings[0].edad)||0) : null;
  const minSibAge = sortedSiblings.length ? (getNum(sortedSiblings[sortedSiblings.length-1].edad)||0) : null;

  if (sortedSiblings.length > 0) {
      if (maxSibAge !== null && pAge > maxSibAge) insertIndex = 0;
      else if (minSibAge !== null && pAge < minSibAge) insertIndex = sortedSiblings.length;
  }

  const sequence = [...sortedSiblings];
  sequence.splice(insertIndex, 0, patient);
  const leftSeq = sequence.slice(0, insertIndex);
  const rightSeq = sequence.slice(insertIndex + 1);

  leftSeq.forEach(s => hermanosLeft.appendChild(crearNodo(s)));
  pacienteSlot.appendChild(crearNodo(patient));
  rightSeq.forEach(s => hermanosRight.appendChild(crearNodo(s)));

  /* --- BLOQUE CORREGIDO: DISTRIBUCI칍N DE PAREJAS Y EX-PAREJAS --- */
  if (partners.length > 0) {
  
    // 1. Separar pareja ACTUAL de las EX-parejas
    // Criterio: La 'actual' es la que NO tiene fecha fin, o la m치s reciente si todas tienen fin.
    // Ordenamos por fecha para encontrar la m치s reciente f치cil
    let allSorted = ordenarParejasPorFecha([...partners], true); // Descendente (M치s nuevo primero)
  
    // Asumimos que la primera de la lista ordenada es la "actual" o "칰ltima relevante"
    let currentPartner = allSorted[0]; 
    let exPartners = allSorted.slice(1); // El resto son exes

    // 2. Determinar posici칩n seg칰n el sexo del PACIENTE
    // REGLA: Pareja actual va al lado opuesto del sexo del paciente, Exes van al lado contrario de la actual.
  
    const pacienteEsHombre = (patient.sexo === 'M');

    if (pacienteEsHombre) {
        // === PACIENTE HOMBRE ===
        // Pareja Actual (Mujer) -> A su DERECHA (Right Slot)
        partnerRightSlot.appendChild(crearNodo(currentPartner));

        // Ex-Parejas -> A su IZQUIERDA (Left Slot)
        // OJO: En el slot izquierdo (justify-flex-end), el 칰ltimo elemento a침adido queda pegado al centro.
        // Queremos: [Ex Vieja] [Ex Nueva] [PACIENTE]
        // As칤 que ordenamos Cronol칩gicamente (Ascendente)
        let exesOrdenados = ordenarParejasPorFecha(exPartners, false); // false = ascendente (viejo a nuevo)
        exesOrdenados.forEach(ex => partnerLeftSlot.appendChild(crearNodo(ex)));
    } 
    else {
        // === PACIENTE MUJER ===
        // Pareja Actual (Hombre) -> A su IZQUIERDA (Left Slot)
        partnerLeftSlot.appendChild(crearNodo(currentPartner));

        // Ex-Parejas -> A su DERECHA (Right Slot)
        // En el slot derecho (justify-flex-start), el primer elemento queda pegado al centro.
        // Queremos: [PACIENTE] [Ex Nueva] [Ex Vieja]
        // As칤 que ordenamos Descendente (Nuevo a Viejo)
        // (Ya lo tenemos en allSorted, pero filtramos solo los exes)
        let exesOrdenados = ordenarParejasPorFecha(exPartners, true); // true = descendente
        exesOrdenados.forEach(ex => partnerRightSlot.appendChild(crearNodo(ex)));
    }
  }

  children.sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0))
    .forEach(h => hijosSlot.appendChild(crearNodo(h)));

  requestAnimationFrame(() => {
    alinearGenograma();
    requestAnimationFrame(() => {
      dibujarConexiones(); 
    });
  });
}

/* ========== DIBUJO DE CONEXIONES ========== */
function dibujarConexiones() {
  const width = Math.max(genogramaContainer.scrollWidth, genogramaContainer.offsetWidth);
  const height = Math.max(genogramaContainer.scrollHeight, genogramaContainer.offsetHeight);
  const rect = genogramaContainer.getBoundingClientRect(); 
  
  if (!stage) {
    stage = new Konva.Stage({ container: 'conexiones', width, height });
    layer = new Konva.Layer();
    stage.add(layer);
  } else {
    stage.width(width); 
    stage.height(height);
    layer.destroyChildren();
  }

  function centerOf(el) {
    if (!el) return null;
    const r = el.getBoundingClientRect();
    return {
      x: r.left + r.width / 2 - rect.left + genogramaContainer.scrollLeft,
      y: r.top + r.height / 2 - rect.top + genogramaContainer.scrollTop,
      top: r.top - rect.top + genogramaContainer.scrollTop,
      bottom: r.bottom - rect.top + genogramaContainer.scrollTop
    };
  }

  const fatherDom = padreSlot.querySelector('.persona');
  const motherDom = madreSlot.querySelector('.persona');
  const partnerDom = partnerLeftSlot.querySelector('.persona') || partnerRightSlot.querySelector('.persona');
  const patientDom = pacienteSlot.querySelector('.persona');
  
  const leftSibs = Array.from(hermanosLeft.querySelectorAll('.persona'));
  const rightSibs = Array.from(hermanosRight.querySelectorAll('.persona'));
  const hijosDom = Array.from(hijosSlot.querySelectorAll('.persona'));

  // 1) Padres
  if (fatherDom && motherDom) {
    const cf = centerOf(fatherDom), cm = centerOf(motherDom);
    layer.add(new Konva.Line({ points: [cf.x, cf.y, cm.x, cm.y], stroke: 'black', strokeWidth: 2 }));
  }

  // 2) Padres -> Descendencia
  const allChildren = [...leftSibs, patientDom, ...rightSibs].filter(Boolean);
  if ((fatherDom || motherDom) && allChildren.length) {
    let originX, originY;
    if (fatherDom && motherDom) {
      const cf = centerOf(fatherDom), cm = centerOf(motherDom);
      originX = (cf.x + cm.x) / 2;
      originY = (cf.y + cm.y) / 2; 
    } else {
      const single = centerOf(fatherDom || motherDom);
      originX = single.x; originY = single.bottom;
    }

    const minTop = Math.min(...allChildren.map(s => centerOf(s).top));
    const yBar = (originY + minTop) / 2 + 10;

    layer.add(new Konva.Line({ points: [originX, originY, originX, yBar], stroke: 'black', strokeWidth: 2 }));

    allChildren.forEach(s => {
      const c = centerOf(s);
      layer.add(new Konva.Line({ points: [c.x, c.top, c.x, yBar], stroke: 'black', strokeWidth: 2 }));
      layer.add(new Konva.Line({ points: [originX, yBar, c.x, yBar], stroke: 'black', strokeWidth: 2 }));
    });
  }

  // ===============================================
  // 3) MATRIMONIOS M칔LTIPLES (L칩gica de Cadena / Eslabones)
  // ===============================================
  let marriageY = 0; 
  let activePartnerCenter = null; 

  // Obtenemos todos los nodos visuales de parejas
  const allPartnerNodes = [
      ...Array.from(partnerLeftSlot.querySelectorAll('.persona')),
      ...Array.from(partnerRightSlot.querySelectorAll('.persona'))
  ];

  if (patientDom && allPartnerNodes.length > 0) {
    const cPatient = centerOf(patientDom);
    
    // 1. CALCULAR ALTURA DE LA L칈NEA
    let maxBottom = cPatient.bottom;
    allPartnerNodes.forEach(n => {
        const c = centerOf(n);
        if (c.bottom > maxBottom) maxBottom = c.bottom;
    });
    marriageY = maxBottom + 25; 

    // 2. CREAR LISTA ORDENADA VISUALMENTE (De Izquierda a Derecha)
    // Esto es vital: Mezclamos al Paciente y a las Parejas en una sola lista
    // y los ordenamos por coordenada X. As칤 sabemos qui칠n est치 al lado de qui칠n.
    let visualChain = [];
    
    // A) Agregamos Paciente
    visualChain.push({ 
        type: 'patient', 
        x: cPatient.x, 
        center: cPatient, 
        id: patient.id 
    });
    
    // B) Agregamos Parejas
    allPartnerNodes.forEach(node => {
        const c = centerOf(node);
        visualChain.push({ 
            type: 'partner', 
            x: c.x, 
            center: c, 
            id: node.dataset.id 
        });
    });

    // C) Ordenamos por posici칩n X (Izquierda -> Derecha)
    visualChain.sort((a, b) => a.x - b.x);

    // 3. DIBUJAR LA L칈NEA BASE HORIZONTAL
    // Conectamos desde el primero de la izquierda hasta el 칰ltimo de la derecha
    const startX = visualChain[0].x;
    const endX = visualChain[visualChain.length - 1].x;
    
    layer.add(new Konva.Line({ 
        points: [startX, marriageY, endX, marriageY], 
        stroke: 'black', strokeWidth: 2 
    }));

    // Buscamos d칩nde qued칩 el paciente en la lista ordenada
    const patientIndex = visualChain.findIndex(n => n.type === 'patient');

    // 4. PROCESAR CADA NODO PARA S칈MBOLOS Y TALLOS
    visualChain.forEach((node, index) => {
        // A. Tallo Vertical (Bajada desde la persona a la l칤nea)
        layer.add(new Konva.Line({ 
            points: [node.x, node.center.y, node.x, marriageY], 
            stroke: 'black', strokeWidth: 2 
        }));

        // Si es el paciente, no lleva s칤mbolos de relaci칩n sobre s칤 mismo
        if (node.type === 'patient') return;

        // B. L칩gica de "El Vecino" (Neighbor) para calcular el centro del s칤mbolo
        // Si el nodo est치 a la izquierda del paciente, su "siguiente" es el de la derecha (index + 1)
        // Si el nodo est치 a la derecha del paciente, su "siguiente" es el de la izquierda (index - 1)
        let neighbor = null;

        if (index < patientIndex) {
            neighbor = visualChain[index + 1]; // Mira hacia la derecha (hacia el paciente)
        } else {
            neighbor = visualChain[index - 1]; // Mira hacia la izquierda (hacia el paciente)
        }

        // C. Calcular coordenadas del S칤mbolo
        // Exactamente en el medio entre este nodo y su vecino
        const midX = (node.x + neighbor.x) / 2;

        const pData = partners.find(p => p.id === node.id);
        if (pData) {
            const h = 8; 
            const symbolConfig = { stroke: 'black', strokeWidth: 2 };
            const tipo = pData.tipoRelacion;

            // Dibujar s칤mbolos (//, /, etc)
            if (tipo === 'separacion') {
                layer.add(new Konva.Line({ points: [midX - 4, marriageY + h, midX + 4, marriageY - h], ...symbolConfig }));
            } else if (tipo === 'divorcio') {
                layer.add(new Konva.Line({ points: [midX - 6, marriageY + h, midX - 2, marriageY - h], ...symbolConfig }));
                layer.add(new Konva.Line({ points: [midX + 2, marriageY + h, midX + 6, marriageY - h], ...symbolConfig }));
            } else if (tipo === 'reconciliacion') {
                layer.add(new Konva.Line({ points: [midX - 8, marriageY - h, midX + 8, marriageY + h], ...symbolConfig }));
            }

            // Tallo punteado si es "pareja de hecho"
            if (tipo === 'de_hecho') {
                 // Truco visual: pintamos l칤nea blanca encima y luego punteada negra
                 layer.add(new Konva.Line({ points: [node.x, node.center.y, node.x, marriageY], stroke: 'white', strokeWidth: 2 }));
                 layer.add(new Konva.Line({ points: [node.x, node.center.y, node.x, marriageY], stroke: 'black', strokeWidth: 2, dash: [10, 5] }));
            }

            // Detectar "pareja activa" para conectar hijos luego
            if (!activePartnerCenter && (tipo === 'normal' || tipo === 'de_hecho')) {
                activePartnerCenter = node.center;
            }
        }
    });
    
    // Fallback: Si todas son ex-parejas, usamos al paciente para que salgan los hijos
    // (Opcional, depende de tu l칩gica de negocio)
  }

  // ===============================================
  // 4) HIJOS (Adaptado para multipareja)
  // ===============================================
  if (patientDom && hijosDom.length) {
    const cPatient = centerOf(patientDom);
    let startX, startY;

    if (activePartnerCenter) {
      // Si hay pareja, salimos del medio entre Paciente y Pareja Activa
      startX = (cPatient.x + activePartnerCenter.x) / 2;
      startY = marriageY; 
    } else {
      // Madre/Padre soltero
      startX = cPatient.x;
      startY = cPatient.bottom;
    }

    const minChildTop = Math.min(...hijosDom.map(h => centerOf(h).top));
    const yEnd = (startY + minChildTop) / 2 + 15;

    // Tallo vertical
    layer.add(new Konva.Line({ points: [startX, startY, startX, yEnd], stroke: 'black', strokeWidth: 2 }));

    // Barra horizontal sobre los hijos
    const allX = hijosDom.map(h => centerOf(h).x);
    const minX = Math.min(...allX);
    const maxX = Math.max(...allX);
    layer.add(new Konva.Line({ points: [minX, yEnd, maxX, yEnd], stroke: 'black', strokeWidth: 2 }));

    // Bajadas individuales
    for (let i = 0; i < hijosDom.length; i++) {
      const hNode = hijosDom[i];
      const hData = children.find(c => c.id === hNode.dataset.id); 
      if (!hData) continue; 

      const ch = centerOf(hNode);
      const tipo = hData.tipoHijo || 'biologico';

      // --- CASO GEMELOS / MELLIZOS ---
      let esParejaGemelos = false;
      if (i < hijosDom.length - 1) {
        const nextNode = hijosDom[i+1];
        const nextData = children.find(c => c.id === nextNode.dataset.id);
        
        if (nextData && (tipo === 'mellizo' || tipo === 'gemelo') && (nextData.tipoHijo === tipo)) {
             esParejaGemelos = true;
             const chNext = centerOf(nextNode);
             
             // Punto medio tri치ngulo
             const midX = (ch.x + chNext.x) / 2;
             
             layer.add(new Konva.Line({ points: [midX, yEnd, ch.x, ch.top], stroke: 'black', strokeWidth: 2 }));
             layer.add(new Konva.Line({ points: [midX, yEnd, chNext.x, chNext.top], stroke: 'black', strokeWidth: 2 }));
             
             if (tipo === 'gemelo') {
               const barY = (yEnd + ch.top) / 2 + 5;
               const ratio = 0.5;
               const x1 = midX + (ch.x - midX) * ratio;
               const x2 = midX + (chNext.x - midX) * ratio;
               layer.add(new Konva.Line({ points: [x1, barY, x2, barY], stroke: 'black', strokeWidth: 2 }));
             }
             i++; // Saltar el siguiente hermano
             continue; 
        }
      }

      // --- CASO NORMAL O ADOPTADO ---
      const configLinea = { 
        stroke: 'black', strokeWidth: 2,
        dash: (tipo === 'adoptado') ? [5, 5] : [] 
      };
      layer.add(new Konva.Line({ points: [ch.x, yEnd, ch.x, ch.top], ...configLinea }));
    }
  }

  layer.draw();
}

/* ========== Eventos ========== */
agregarPacienteBtn.onclick = () => {
  const nombre = document.getElementById('nombre').value.trim();
  if (!nombre) return alert('Ingresa nombre');
  patient = { id:uid(), nombre, apellido:document.getElementById('apellido').value, edad:document.getElementById('edad').value, sexo:document.getElementById('sexo').value, esPaciente:true };
  formPaciente.style.display='none'; render();
};

function abrirMenu(x,y){ menu.style.left=x+'px'; menu.style.top=y+'px'; menu.classList.remove('oculto'); }
function cerrarMenu(){ menu.classList.add('oculto'); seleccionado=null; }
menuAgregarBtn.onclick = ()=>{ cerrarMenu(); abrirFormFamiliar(); };
menuEliminarBtn.onclick = ()=>{ if(seleccionado) eliminarSeleccionado(); cerrarMenu(); };

function abrirFormFamiliar(){ 
  formFamiliar.classList.remove('oculto'); 
  // Disparamos el evento change para configurar estados correctos al abrir
  famRolSelect.dispatchEvent(new Event('change'));
  actualizarCamposPorEstado();
}
function cerrarFormFamiliar(){ formFamiliar.classList.add('oculto'); }

/* --- C. BOT칍N GUARDAR (CORREGIDO) --- */
guardarFamiliarBtn.onclick = () => {
  // 1. CAPTURA DE TODOS LOS INPUTS (Incluyendo los nuevos de fechas)
  const nomInput = document.getElementById('famNombre');
  const apeInput = document.getElementById('famApellido');
  const edadInput = document.getElementById('famEdad');
  const sexoInput = document.getElementById('famSexo');
  const rolInput = document.getElementById('famRol');
  const estadoInput = document.getElementById('famEstado');
  const saludInput = document.getElementById('famSalud');
  const lgtbInput = document.getElementById('famLgtb');
  const tipoRelacionInput = document.getElementById('famTipoRelacion'); 
  const tipoHijoInput = document.getElementById('famTipoHijo');
  
  // --- NUEVO: Capturar los inputs de fecha aqu칤 arriba ---
  const anioInicioInput = document.getElementById('relAnioInicio');
  const anioFinInput = document.getElementById('relAnioFin');

  // Validaciones b치sicas
  const estado = estadoInput.value;
  const nom = nomInput.value.trim();
  const permiteSinNombre = ['embarazo', 'aborto_esp', 'aborto_prov'].includes(estado);
  
  if (!nom && !permiteSinNombre) return alert("Por favor ingresa un nombre");

  // Funci칩n auxiliar para limpiar el a침o (convierte texto a n칰mero o null)
  const getYearVal = (input) => {
    const val = parseInt(input.value.trim());
    // Si es un n칰mero v치lido y mayor a 1800, lo guardamos. Si no, null.
    return (Number.isFinite(val) && val > 1800) ? val : null;
  };

  // 2. CREACI칍N DEL OBJETO
  const p = { 
    id: uid(), 
    nombre: nom || '', 
    apellido: apeInput.value, 
    edad: edadInput.value, 
    sexo: sexoInput.value,
    estado: estado, 
    salud: saludInput.value,
    lgtb: lgtbInput.checked,
    tipoRelacion: tipoRelacionInput.value,
    tipoHijo: tipoHijoInput.value,
    // Como ya definimos 'anioInicioInput' y 'getYearVal' arriba, esto ya no dar치 error
    relAnioInicio: (rolInput.value === 'pareja') ? getYearVal(anioInicioInput) : null,
    relAnioFin: (rolInput.value === 'pareja') ? getYearVal(anioFinInput) : null
  };

  // 3. LOGICA DE GUARDADO (Igual que antes)
  const rol = rolInput.value;
  if (rol === 'padre') { 
    if (p.sexo === 'M') parents.father = p; else parents.mother = p; 
  }
  else if(rol==='pareja') {
    // Si estamos editando uno existente, lo reemplazamos
    const idx = partners.findIndex(x => x.id === p.id);
    if (idx >= 0) partners[idx] = p;
    else partners.push(p); // Si es nuevo, lo a침adimos a la lista
  }
  else if (rol === 'hermano') siblings.push(p);
  else if (rol === 'hijo') children.push(p);
  
  // 4. RESETEAR FORMULARIO
  nomInput.value = ''; apeInput.value = ''; edadInput.value = '';
  estadoInput.value = 'vivo'; saludInput.value = 'ninguno';
  lgtbInput.checked = false;
  tipoRelacionInput.value = 'normal';
  tipoHijoInput.value = 'biologico';
  sexoInput.value = 'M'; rolInput.value = 'padre';
  
  // Resetear fechas tambi칠n
  anioInicioInput.value = '';
  anioFinInput.value = '';

  cerrarFormFamiliar(); 
  render();
};

function eliminarSeleccionado(){
  const id = seleccionado.id;
  if(patient && patient.id===id) { patient=null; formPaciente.style.display='block'; }
  if(parents.father && parents.father.id===id) parents.father=null;
  if(parents.mother && parents.mother.id===id) parents.mother=null;
  partners = partners.filter(p => p.id !== id);
  siblings = siblings.filter(s=>s.id!==id);
  children = children.filter(c=>c.id!==id);
  render();
}

window.addEventListener('resize', () => {
  if (stage) { stage.destroy(); stage=null; layer=null; }
  alinearGenograma();
  requestAnimationFrame(() => dibujarConexiones());
});

const params = new URLSearchParams(window.location.search);
if(params.has('nombre')){
   patient = { id:uid(), nombre:params.get('nombre'), apellido:params.get('apellido')||'', edad:params.get('edad')||0, sexo:params.get('sexo')||'M', esPaciente:true };
   formPaciente.style.display='none';
}

render();
</script>
</body>
</html>