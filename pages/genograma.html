<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Genograma</title>
  <link rel="stylesheet" href="../style/style_geno.css">
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <h1>Genograma</h1>
  <button id="btnGuardarDB" class="btn-save">üíæ Guardar Cambios</button>
  <button id="btnExportarPDF" class="btn-save" style="margin-left:10px; background-color:#e74c3c;">üìÑ Exportar PDF</button>

  <div class="form-wrapper" id="formPaciente">
    <h3>Agregar paciente</h3>
    <label>Nombre: <input type="text" id="nombre" /></label>
    <label>Apellido: <input type="text" id="apellido" /></label>
    <label>Edad: <input type="number" id="edad" min="0" /></label>
    <label>Sexo:
      <select id="sexo">
        <option value="M">Masculino</option>
        <option value="F">Femenino</option>
      </select>
    </label>
    <div style="margin-top:8px">
      <button id="agregarPaciente">Agregar paciente</button>
    </div>
  </div>

  <div class="genograma-container">
    <div id="conexiones"></div>

    <div class="fila ancentros" id="bisabuelos" style="margin-bottom: 40px; min-height:80px; display:flex; justify-content:center; gap:60px;">
        <div id="bisabuelos-paternos" style="display:flex; gap:20px; justify-content:flex-end;"></div>
        <div id="bisabuelos-maternos" style="display:flex; gap:20px; justify-content:flex-start;"></div>
      </div>
      
      <div class="fila ancentros" id="abuelos" style="margin-bottom: 40px; min-height:80px; display:flex; justify-content:center; gap:60px;">
         <div id="abuelos-paternos" style="display:flex; gap:20px; justify-content:flex-end;"></div>
         <div id="abuelos-maternos" style="display:flex; gap:20px; justify-content:flex-start;"></div>
      </div>

      <div class="fila padres" id="padres">
        <div class="parent-slot" id="padre-slot"></div>
        <div class="parent-slot" id="madre-slot"></div>
      </div>

      <div class="fila middle-row" id="middle">
        <div class="pareja-slot" id="partner-left-slot"></div>
        <div class="center-block" id="center-block">
          <div class="hermanos left" id="hermanos-left"></div>
          <div class="paciente-slot" id="paciente-slot"></div>
          <div class="hermanos right" id="hermanos-right"></div>
        </div>
        <div class="pareja-slot" id="partner-right-slot"></div>
      </div>

      <div class="fila hijos" id="hijos" style="margin-top: 40px;"></div>

      <div class="fila nietos" id="nietos" style="margin-top: 40px; min-height:80px; display:flex; justify-content:center; gap:20px;"></div>
      
       <div class="fila bisnietos" id="bisnietos" style="margin-top: 40px; min-height:80px; display:flex; justify-content:center; gap:20px;"></div>
    </div>
  </div>

  <div id="formFamiliar" class="modal oculto" role="dialog" aria-hidden="true">
    <div class="modal-inner">
      <h4>Agregar familiar</h4>
      <label>Nombre: <input type="text" id="famNombre" /></label>
      <label>Apellido: <input type="text" id="famApellido" /></label>
      <label>Edad: <input type="number" id="famEdad" min="0" /></label>
      
      <label>Sexo:
        <select id="famSexo">
          <option value="M">Masculino</option>
          <option value="F">Femenino</option>
        </select>
      </label>

      <label>Rol:
        <select id="famRol">
          <option value="bisabuelo">Bisabuelo/a</option>
          <option value="abuelo">Abuelo/a</option>
          <option value="padre">Padre/Madre</option>
          <option value="pareja">Pareja (del Paciente)</option>
          <option value="hermano">Hermano/a</option>
          <option value="hijo">Hijo/a</option>
          <option value="nieto">Nieto/a</option>
          <option value="bisnieto">Bisnieto/a</option>
          <option value="pareja_descendiente">Pareja de Descendiente</option>
        </select>
      </label>

      <div id="divTargetId" style="display:none; margin-top:8px; background:#eef; padding:5px;">
        <label id="lblTargetId">Vincular con:</label>
        <select id="famTargetId" style="width:100%"></select>
      </div>
        
      <div id="divTipoHijo" style="display:none; margin-top:8px;">
        <label>Tipo de Hijo:
          <select id="famTipoHijo" style="width:100%">
            <option value="biologico">Biol√≥gico (Normal)</option>
            <option value="adoptado">Adoptado (L√≠nea Punteada)</option>
            <option value="mellizo">Mellizo (Dizig√≥tico)</option>
            <option value="gemelo">Gemelo (Monocig√≥tico/Id√©ntico)</option>
          </select>
        </label>
      </div>

      <label>Salud / Problemas:
        <select id="famSalud" style="width:100%">
          <option value="ninguno">Ninguno</option>
          <option value="abuso">Abuso Alcohol/Drogas</option>
          <option value="ingreso">Ingreso / Recuperaci√≥n</option> 
          <option value="sospecha">Sospecha de Abuso</option>
          <option value="mental">Prob. Mentales / Psicol√≥gicos</option>
          <option value="ambos">Comorbilidad (Abuso + Mental)</option>
        </select>
      </label>

      <label>Estado Vital:
        <select id="famEstado" style="width:100%">
          <option value="vivo">Vivo</option>
          <option value="fallecido">Fallecido</option>
          <option value="embarazo">Embarazo</option>
          <option value="neonato_x">Muerte al nacer</option>
          <option value="aborto_esp">Aborto Espont√°neo</option>
          <option value="aborto_prov">Aborto Provocado</option>
        </select>
      </label>

      <label style="display:inline-flex; align-items:center; gap:5px; margin-top:5px;">
        <input type="checkbox" id="famLgtb" /> 
        LGTBIQ+
      </label>

      <div id="lblDivorcio" style="display:none; margin-top:8px;">
        <label>Estado de la Relaci√≥n:
          <select id="famTipoRelacion" style="width:100%">
            <option value="normal">Relaci√≥n Vigente (Matrimonio)</option>
            <option value="de_hecho">Pareja de hecho / Amante</option>
            <option value="separacion">Separaci√≥n</option>
            <option value="divorcio">Divorcio</option>
            <option value="reconciliacion">Reconciliaci√≥n tras Divorcio</option> 
          </select>
        </label>
      </div>

      <div id="bloqueFechasRelacion" style="display:none; margin-top:8px; padding:10px; background:#f0f0f0; border-radius:4px;">
        <label style="font-weight:bold;">Cronolog√≠a de la Relaci√≥n:</label>
        <div style="display:flex; gap:10px; margin-top:5px;">
          <label style="flex:1;">A√±o Inicio: 
            <input type="number" id="relAnioInicio" placeholder="Ej: 1990" min="1900" max="2030" style="width:100%">
          </label>
          <label style="flex:1;">A√±o Fin (si aplica): 
            <input type="number" id="relAnioFin" placeholder="Ej: 2005" min="1900" max="2030" style="width:100%">
          </label>
        </div>
        <small style="color:#666;">Necesario para ordenar relaciones m√∫ltiples.</small>
      </div>

      <div class="modal-actions" style="margin-top:8px;">
        <button id="guardarFamiliarBtn">Agregar</button>
        <button type="button" onclick="cerrarFormFamiliar()">Cancelar</button>
      </div>
    </div>
  </div>

  <div id="menuAcciones" class="menu-acciones oculto">
    <button id="menuAgregar">Agregar familiar</button>
    <button id="menuModificar">Modificar</button>
    <button id="menuEliminar">Eliminar</button>
    <button onclick="cerrarMenu()">Cerrar</button>
  </div>

<script>
/* ========== Modelo de datos ========== */
function uid(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,8); }

let patient = null;
let parents = { father: null, mother: null };
let partners = []; 
let siblings = [];
let children = [];
// NUEVOS ARRAYS
let grandparents = [];      // Abuelos (linked to parents)
let greatGrandparents = []; // Bisabuelos (linked to grandparents)
let grandchildren = [];     // Nietos (linked to children)
let greatGrandchildren = [];// Bisnietos (linked to grandchildren)
let descendantPartners = [];// Parejas de hijos/nietos

let seleccionado = null;

/* ========== Selectores DOM ========== */
const padreSlot = document.getElementById('padre-slot');
const madreSlot = document.getElementById('madre-slot');
const partnerLeftSlot = document.getElementById('partner-left-slot');
const partnerRightSlot = document.getElementById('partner-right-slot');
const hermanosLeft = document.getElementById('hermanos-left');
const hermanosRight = document.getElementById('hermanos-right');
const pacienteSlot = document.getElementById('paciente-slot');
const hijosSlot = document.getElementById('hijos');
const genogramaContainer = document.querySelector('.genograma-container');
const middleRow = document.getElementById('middle'); 
const hijosRow = document.getElementById('hijos'); 

const formPaciente = document.getElementById('formPaciente');
const agregarPacienteBtn = document.getElementById('agregarPaciente');
const menu = document.getElementById('menuAcciones');
const menuAgregarBtn = document.getElementById('menuAgregar');
const menuEliminarBtn = document.getElementById('menuEliminar');
const formFamiliar = document.getElementById('formFamiliar');
const menuModificarBtn = document.getElementById('menuModificar'); // NUEVO
let modoEdicion = false; // NUEVO: Controla si guardamos o editamos
const guardarFamiliarBtn = document.getElementById('guardarFamiliarBtn');

const famRolSelect = document.getElementById('famRol');

/* --- MODIFICAR: Funci√≥n para mostrar/ocultar opciones de PAREJA --- */
const divRelacion = document.getElementById('lblDivorcio');
const tipoRelacionInput = document.getElementById('famTipoRelacion');
// NUEVO SELECTOR:
const bloqueFechasRelacion = document.getElementById('bloqueFechasRelacion');

function toggleDivorcioOption() {
  const esPareja = (famRolSelect.value === 'pareja');

  if (esPareja) {
    divRelacion.style.display = 'block';
    // NUEVO: Mostrar fechas
    bloqueFechasRelacion.style.display = 'block';
  } else {
    divRelacion.style.display = 'none';
    // NUEVO: Ocultar fechas y resetear
    bloqueFechasRelacion.style.display = 'none';
    tipoRelacionInput.value = 'normal';
    document.getElementById('relAnioInicio').value = '';
    document.getElementById('relAnioFin').value = '';
  }
}

/* --- L√ìGICA DE FORMULARIO DIN√ÅMICO --- */
const divTargetId = document.getElementById('divTargetId');
const lblTargetId = document.getElementById('lblTargetId');
const famTargetId = document.getElementById('famTargetId');

famRolSelect.addEventListener('change', () => {
  const rol = famRolSelect.value;
  divTargetId.style.display = 'none';
  famTargetId.innerHTML = '';
  document.getElementById('divTipoHijo').style.display = 'none';
  
  // 1. ABUELOS: Seleccionar a qu√© PADRE pertenecen
  if (rol === 'abuelo') {
    divTargetId.style.display = 'block';
    lblTargetId.textContent = '¬øEs padre/madre de qui√©n? (Selecciona un Padre):';
    if(parents.father) agregarOpcion(parents.father);
    if(parents.mother) agregarOpcion(parents.mother);
  }
  
  // 2. BISABUELOS: Seleccionar a qu√© ABUELO pertenecen
  else if (rol === 'bisabuelo') {
    divTargetId.style.display = 'block';
    lblTargetId.textContent = '¬øEs padre/madre de qui√©n? (Selecciona un Abuelo):';
    grandparents.forEach(p => agregarOpcion(p));
  }

  // 3. HIJOS: Seleccionar qui√©n es el otro progenitor (Pareja del paciente)
  else if (rol === 'hijo') {
    document.getElementById('divTipoHijo').style.display = 'block';
    divTargetId.style.display = 'block';
    lblTargetId.textContent = 'Otro Progenitor (Pareja del Paciente):';
    famTargetId.innerHTML = '<option value="">-- Desconocido / Solo Paciente --</option>';
    partners.forEach(p => agregarOpcion(p));
  }

  // 4. NIETOS: Seleccionar qui√©n es su padre (Uno de tus HIJOS)
  else if (rol === 'nieto') {
    document.getElementById('divTipoHijo').style.display = 'block'; // Opcional si quieres mellizos en nietos
    divTargetId.style.display = 'block';
    lblTargetId.textContent = '¬øHijo de qui√©n? (Selecciona un Hijo):';
    children.forEach(p => agregarOpcion(p));
  }

  // 5. BISNIETOS: Seleccionar qui√©n es su padre (Uno de tus NIETOS)
  else if (rol === 'bisnieto') {
    divTargetId.style.display = 'block';
    lblTargetId.textContent = '¬øHijo de qui√©n? (Selecciona un Nieto):';
    grandchildren.forEach(p => agregarOpcion(p));
  }

  // 6. PAREJA DE DESCENDIENTE: Para darle esposa/esposo a un hijo o nieto
  else if (rol === 'pareja_descendiente') {
    divTargetId.style.display = 'block';
    lblTargetId.textContent = '¬øPareja de qui√©n?';
    // Agregamos Hijos y Nietos a la lista
    const optGroupHijos = document.createElement('optgroup'); optGroupHijos.label = "Hijos";
    children.forEach(c => {
       const o = document.createElement('option'); o.value=c.id; o.textContent=c.nombre; optGroupHijos.appendChild(o);
    });
    famTargetId.appendChild(optGroupHijos);

    const optGroupNietos = document.createElement('optgroup'); optGroupNietos.label = "Nietos";
    grandchildren.forEach(c => {
       const o = document.createElement('option'); o.value=c.id; o.textContent=c.nombre; optGroupNietos.appendChild(o);
    });
    famTargetId.appendChild(optGroupNietos);
    
    // Mostramos opciones de divorcio/fechas
    toggleDivorcioOption(); 
  }

  // L√≥gica para mostrar fechas si es pareja directa o de descendiente
  if (rol === 'pareja' || rol === 'pareja_descendiente') toggleDivorcioOption();
  else { 
      document.getElementById('lblDivorcio').style.display='none'; 
      document.getElementById('bloqueFechasRelacion').style.display='none';
  }
  
  filtrarOpcionesEstado();
});

function agregarOpcion(persona) {
    const option = document.createElement('option');
    option.value = persona.id;
    option.textContent = persona.nombre + ' ' + (persona.apellido||'');
    famTargetId.appendChild(option);
}


/* --- L√ìGICA: FILTRAR ESTADOS SEG√öN ROL --- */
const famEstadoSelect = document.getElementById('famEstado');

function filtrarOpcionesEstado() {
  const rol = famRolSelect.value;
  // Estados que queremos que sean exclusivos para el rol 'hijo'
  const estadosInfantiles = ['embarazo', 'neonato_x', 'aborto_esp', 'aborto_prov'];
  
  for (let i = 0; i < famEstadoSelect.options.length; i++) {
    const opt = famEstadoSelect.options[i];
    
    // Si la opci√≥n actual es una de las "infantiles"
    if (estadosInfantiles.includes(opt.value)) {
      // SOLO mostramos si el rol es exactamente 'hijo'
      if (rol === 'hijo') {
        opt.hidden = false; 
        opt.disabled = false; 
        opt.style.display = 'block';
      } else {
        // Para cualquier otro rol (padre, pareja, hermano), se oculta
        opt.hidden = true; 
        opt.disabled = true; 
        opt.style.display = 'none';
      }
    }
  }

  // Validaci√≥n de seguridad:
  // Si el usuario ten√≠a seleccionado "aborto" y cambia el rol a "Padre",
  // el valor quedar√≠a inv√°lido. Forzamos el cambio a "vivo".
  const valorActual = famEstadoSelect.value;
  if (estadosInfantiles.includes(valorActual) && rol !== 'hijo') {
    famEstadoSelect.value = 'vivo';
    // Llamamos a actualizarCampos para que habilite de nuevo drogas/lgtb si estaban bloqueados
    actualizarCamposPorEstado();
  }
}

/* --- A. L√ìGICA DE BLOQUEO (Sin drogas/LGTB para fetos) --- */
function actualizarCamposPorEstado() {
  const estado = famEstadoSelect.value;
  const saludSelect = document.getElementById('famSalud');
  const lgtbCheck = document.getElementById('famLgtb');
  const estadosInfantiles = ['embarazo', 'neonato_x', 'aborto_esp', 'aborto_prov'];
  
  if (estadosInfantiles.includes(estado)) {
    saludSelect.value = 'ninguno';
    lgtbCheck.checked = false;
    saludSelect.disabled = true;
    lgtbCheck.disabled = true;
    saludSelect.parentElement.style.opacity = '0.5';
    lgtbCheck.parentElement.style.opacity = '0.5';
  } else {
    saludSelect.disabled = false;
    lgtbCheck.disabled = false;
    saludSelect.parentElement.style.opacity = '1';
    lgtbCheck.parentElement.style.opacity = '1';
  }
}

famEstadoSelect.addEventListener('change', actualizarCamposPorEstado);

/* ========== Utilidades ========== */
const getNum = v => { const n = parseInt(v); return Number.isFinite(n) ? n : null; };
function getCenterX(el) { const r = el.getBoundingClientRect(); return r.left + r.width / 2; }

// Funci√≥n para ordenar un array de parejas cronol√≥gicamente.
function ordenarParejasPorFecha(listaParejas, ordenDescendente = true) {
  return listaParejas.sort((a, b) => {
    // Usamos 0 como valor por defecto si no se introdujo a√±o, para evitar errores
    const inicioA = a.relAnioInicio || 0;
    const inicioB = b.relAnioInicio || 0;

    if (ordenDescendente) {
        // Orden: M√°s Reciente -> M√°s Antiguo (Ej: 2020, 2010, 1990)
        // Esto se usa para las parejas que est√°n "m√°s cerca" del sujeto central.
        return inicioB - inicioA; 
    } else {
        // Orden: M√°s Antiguo -> M√°s Reciente (Ej: 1990, 2010, 2020)
        return inicioA - inicioB;
    }
  });
}

/* ========== Crear nodo persona ========== */
function crearNodo(persona) {
  const div = document.createElement('div');
  
  let clases = 'persona ' + (persona.sexo === 'M' ? 'hombre' : 'mujer');
  if (persona.esPaciente) clases += ' paciente';
  
  if (persona.estado === 'fallecido') clases += ' fallecido';
  else if (persona.estado === 'embarazo') clases += ' embarazo';
  else if (persona.estado === 'neonato_x') clases += ' neonato-x';
  else if (persona.estado === 'aborto_esp') clases += ' aborto-esp';
  else if (persona.estado === 'aborto_prov') clases += ' aborto-prov';

  if (persona.salud && persona.salud !== 'ninguno') clases += ' patron-' + persona.salud; 
  if (persona.lgtb) clases += ' lgtb'; 
  
  div.className = clases;
  div.dataset.id = persona.id;

  if (persona.lgtb) {
    const tri = document.createElement('div');
    tri.className = 'simbolo-lgtb';
    div.appendChild(tri);
  }

  const sinTexto = ['aborto_esp', 'aborto_prov']; 
  if (!sinTexto.includes(persona.estado)) {
    const nombre = document.createElement('div');
    nombre.className = 'nombre';
    nombre.textContent = persona.nombre + (persona.apellido ? (' ' + persona.apellido) : '');

    const edad = document.createElement('div');
    edad.className = 'edad';
    edad.textContent = persona.edad ? (persona.edad + ' a√±os') : '';

    div.appendChild(nombre);
    div.appendChild(edad);
  }
  
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    seleccionado = persona;
    abrirMenu(e.pageX, e.pageY);
  });
  
  return div;
}

/* ========== Konva Config ========== */
let stage = null;
let layer = null;

/* --- ALINEACI√ìN INTELIGENTE (Detecta vecinos para no solapar hijos) --- */
function alinearGenograma() {
  // 1. LIMPIEZA INICIAL
  middleRow.style.transform = '';
  hijosRow.style.transform = '';
  document.querySelectorAll('.child-group').forEach(g => g.style.transform = '');
  document.querySelectorAll('.middle-row .persona').forEach(p => p.style.transform = '');

  const patientDom = pacienteSlot.querySelector('.persona');
  if (!patientDom) return;

  const cPatient = getCenterX(patientDom);

  // --- A. Recopilar datos ---
  const groups = Array.from(document.querySelectorAll('.child-group'));
  if (groups.length === 0) return;

  let groupData = groups.map(group => {
    const rect = group.getBoundingClientRect();
    const partnerId = group.dataset.partnerId;
    let targetX = 0;

    if (partnerId === 'single') {
        targetX = cPatient;
    } else {
        const partnerDom = document.querySelector(`.persona[data-id="${partnerId}"]`);
        
        if (partnerDom) {
            const cPartner = getCenterX(partnerDom);
            
            // --- NUEVO: L√ìGICA DE VECINOS ---
            // En lugar de ir siempre hasta el Paciente, buscamos qui√©n est√° al lado
            // para poner a los hijos en el hueco libre inmediato.
            let obstacleDom = null;

            // Verificamos si la pareja est√° en el slot Izquierdo o Derecho
            if (partnerLeftSlot.contains(partnerDom)) {
                // IZQUIERDA: El vecino hacia el centro es el "siguiente hermano" en el DOM
                // (Porque el orden es: Ex1, Ex2, ... Paciente)
                obstacleDom = partnerDom.nextElementSibling;
                // Si no hay m√°s ex-parejas a la derecha, el obst√°culo es el Paciente
                if (!obstacleDom) obstacleDom = patientDom;
            } 
            else if (partnerRightSlot.contains(partnerDom)) {
                // DERECHA: El vecino hacia el centro es el "hermano anterior"
                // (Porque el orden es: Paciente ... Pareja1, Pareja2)
                obstacleDom = partnerDom.previousElementSibling;
                // Si no hay nadie antes, el obst√°culo es el Paciente
                if (!obstacleDom) obstacleDom = patientDom;
            }

            // Calculamos el centro del obst√°culo (Ex2 o Paciente)
            const cObstacle = obstacleDom ? getCenterX(obstacleDom) : cPatient;

            // EL CENTRO SEGURO: Promedio entre la Pareja y su Vecino Inmediato
            targetX = (cPartner + cObstacle) / 2;

        } else {
            targetX = cPatient;
        }
    }

    return {
        node: group,
        partnerId: partnerId,
        rect: rect,
        width: rect.width,
        currentX: rect.left + rect.width / 2, 
        idealX: targetX,      
        finalX: targetX       
    };
  });

  // Ordenar visualmente para la f√≠sica
  groupData.sort((a, b) => a.idealX - b.idealX);

  // --- B. Resolver Colisiones (Igual que antes) ---
  const GAP = 40; 

  for (let step = 0; step < 3; step++) {
      for (let i = 0; i < groupData.length - 1; i++) {
          const g1 = groupData[i];
          const g2 = groupData[i + 1];

          const g1Right = g1.finalX + g1.width / 2;
          const g2Left = g2.finalX - g2.width / 2;

          if (g1Right + GAP > g2Left) {
              const overlap = (g1Right + GAP) - g2Left;
              g1.finalX -= overlap / 2;
              g2.finalX += overlap / 2;
          }
      }
  }

  // --- C. Aplicar Movimientos ---
  groupData.forEach(d => {
      // 1. Mover Hijos
      const shiftChildren = d.finalX - d.currentX;
      d.node.style.transform = `translateX(${shiftChildren}px)`;

      // 2. Mover Pareja (Efecto Palanca)
      if (d.partnerId !== 'single') {
          const deltaCenter = d.finalX - d.idealX; 
          if (Math.abs(deltaCenter) > 0.1) {
             const partnerNode = document.querySelector(`.persona[data-id="${d.partnerId}"]`);
             if (partnerNode) {
                 // Nota: Aqu√≠ usamos un factor 1.5 o 2 suave, porque ahora el punto de referencia
                 // no es fijo (el vecino tambi√©n puede moverse). Usar 2 suele funcionar bien.
                 const partnerShift = deltaCenter * 2;
                 partnerNode.style.transform = `translateX(${partnerShift}px)`;
             }
          }
      }
  });
}

// Funci√≥n auxiliar simple si no la tienes global
function getCenterX(el) { 
    const r = el.getBoundingClientRect(); 
    return r.left + r.width / 2; 
}

/* --- ALINEACI√ìN DE ANCESTROS (Abuelos sobre Padres) --- */
function alinearAncestros() {
  // 1. Alinear Abuelos respecto a los Padres
  alinearNivel('abuelos');
  
  // 2. Alinear Bisabuelos respecto a los Abuelos
  // (Nota: Esto debe ejecutarse despu√©s para tener en cuenta el movimiento de los abuelos)
  requestAnimationFrame(() => {
      alinearNivel('bisabuelos');
  });
}

/* --- AUTO-SEPARACI√ìN DE ABUELOS (Para que quepan los Bisabuelos) --- */
function ajustarSeparacionAbuelos() {
  // Buscamos todos los grupos de abuelos (ej: padres del padre, padres de la madre)
  const gruposAbuelos = document.querySelectorAll('#abuelos .ancestor-group');
  
  gruposAbuelos.forEach(grupo => {
     const personas = Array.from(grupo.children);
     if (personas.length < 2) return; // Si es solo uno, no hay choque posible

     // Calculamos el gap necesario entre cada par de personas (Abuelo - Abuela)
     let maxGap = 20; // Gap m√≠nimo visual

     for(let i=0; i < personas.length - 1; i++) {
         const p1 = personas[i];
         const p2 = personas[i+1];
         
         // Buscar sus bisabuelos correspondientes (padres de p1 y padres de p2)
         const bis1 = document.querySelector(`#bisabuelos .ancestor-group[data-child-id="${p1.dataset.id}"]`);
         const bis2 = document.querySelector(`#bisabuelos .ancestor-group[data-child-id="${p2.dataset.id}"]`);

         // Medimos el ancho de los grupos de bisabuelos (si existen)
         const w1 = bis1 ? bis1.getBoundingClientRect().width : 0;
         const w2 = bis2 ? bis2.getBoundingClientRect().width : 0;
         
         // L√≥gica Geom√©trica:
         // Necesitamos que la distancia entre los centros de p1 y p2 sea suficiente
         // para que sus "techos" (ramas de bisabuelos) no choquen.
         // EspacioRequerido = (MitadRama1 + MitadRama2) + Margen
         const margen = 20;
         const espacioRamas = (w1 / 2) + (w2 / 2) + margen; 
         
         // Convertimos esa distancia entre centros a "gap" (espacio vac√≠o entre bordes)
         const p1w = p1.getBoundingClientRect().width;
         const p2w = p2.getBoundingClientRect().width;
         const espacioCuerpos = (p1w / 2) + (p2w / 2);
         
         const gapNecesario = espacioRamas - espacioCuerpos;
         
         if (gapNecesario > maxGap) maxGap = gapNecesario;
     }

     // Aplicamos el nuevo gap al contenedor de estos abuelos
     grupo.style.gap = `${maxGap}px`;
  });
}

/* --- AUTO-SEPARACI√ìN DE PADRES (Evita choques de abuelos) --- */
function ajustarSeparacionPadres() {
    const padresContainer = document.getElementById('padres');
    
    // 1. Obtener contenedores de ancestros
    const pContainer = document.getElementById('abuelos-paternos');
    const mContainer = document.getElementById('abuelos-maternos');
    const bpContainer = document.getElementById('bisabuelos-paternos');
    const bmContainer = document.getElementById('bisabuelos-maternos');

    // Funci√≥n auxiliar para medir el ancho real visual de un grupo
    const getRealWidth = (container) => {
        if (!container || container.children.length === 0) return 0;
        // Medimos la distancia desde el borde izquierdo del primer elemento 
        // hasta el borde derecho del √∫ltimo elemento
        const first = container.firstElementChild.getBoundingClientRect();
        const last = container.lastElementChild.getBoundingClientRect();
        return last.right - first.left;
    };

    // 2. Calcular ancho m√°ximo de cada "Rama" (Paterna vs Materna)
    const wRamaPaterna = Math.max(getRealWidth(pContainer), getRealWidth(bpContainer));
    const wRamaMaterna = Math.max(getRealWidth(mContainer), getRealWidth(bmContainer));

    // 3. Aplicar Gap Din√°mico
    // Si tenemos ancestros, calculamos cu√°nto espacio necesitan
    if (wRamaPaterna > 0 || wRamaMaterna > 0) {
        const margenSeguridad = 40; 
        const anchoPadreEstimado = 100; // Ancho aprox de la tarjeta del padre
        
        // F√≥rmula geom√©trica: 
        // Distancia necesaria = (MitadRamaIzq + MitadRamaDer) + Margen
        // Gap a aplicar = DistanciaNecesaria - AnchoDelPadreCentral
        const espacioNecesario = (wRamaPaterna / 2) + (wRamaMaterna / 2) + margenSeguridad;
        
        const nuevoGap = Math.max(40, espacioNecesario - anchoPadreEstimado);
        
        padresContainer.style.gap = `${nuevoGap}px`;
    } else {
        // Si no hay ancestros, gap standard
        padresContainer.style.gap = '40px'; 
    }
}

/* --- ALINEACI√ìN EXACTA: PADRES -> PACIENTE (CORREGIDA) --- */
function alinearPadresExactamente() {
  const patientNode = document.querySelector('#paciente-slot .persona');
  const padresRow = document.getElementById('padres');
  
  // 1. IMPORTANTE: Resetear transformaci√≥n previa para medir la posici√≥n "natural"
  padresRow.style.transform = ''; 
  
  if (!patientNode || (!parents.father && !parents.mother)) return;

  // 2. Encontrar el centro objetivo (El centro del Paciente)
  const rectPatient = patientNode.getBoundingClientRect();
  const targetX = rectPatient.left + rectPatient.width / 2;

  // 3. Encontrar el centro "natural" de los Padres (donde los puso el CSS)
  let currentParentX = 0;
  const fatherNode = document.querySelector('#padre-slot .persona');
  const motherNode = document.querySelector('#madre-slot .persona');

  if (fatherNode && motherNode) {
      // Centro promedio entre los dos
      const rF = fatherNode.getBoundingClientRect();
      const rM = motherNode.getBoundingClientRect();
      const centerF = rF.left + rF.width / 2;
      const centerM = rM.left + rM.width / 2;
      currentParentX = (centerF + centerM) / 2;
  } 
  else if (fatherNode) {
      const r = fatherNode.getBoundingClientRect();
      currentParentX = r.left + r.width / 2;
  } 
  else if (motherNode) {
      const r = motherNode.getBoundingClientRect();
      currentParentX = r.left + r.width / 2;
  } else {
      return; 
  }

  // 4. Calcular la diferencia y mover
  const delta = targetX - currentParentX;
  
  // Solo aplicamos si la diferencia es notable (evita micro-movimientos borrosos)
  if (Math.abs(delta) > 0.5) {
      padresRow.style.transform = `translateX(${delta}px)`;
  }
}

function alinearHijosConPadres() {
  // Funci√≥n auxiliar para mover un bloque de familia
  const moverFamilia = (familyDiv, centroPadres) => {
      // 1. En lugar de usar el centro de todo el div, buscamos el centro de los HIJOS BIOL√ìGICOS
      // Identificamos a los hijos biol√≥gicos filtrando aquellos que NO son parejas de descendientes
      const personasEnGrupo = Array.from(familyDiv.querySelectorAll('.persona'));
      
      // Filtramos: Nos quedamos con los que NO est√°n en la lista de 'partners' externos
      // (Es decir, los hijos de sangre de la generaci√≥n anterior)
      const hijosBio = personasEnGrupo.filter(dom => {
         const id = dom.dataset.id;
         // Si el ID existe en descendantPartners, es un agregado (nuera/yerno), lo ignoramos para el centro
         return !descendantPartners.some(dp => dp.id === id);
      });

      if (hijosBio.length === 0) return; // Si no hay hijos bio, no hacemos nada

      // 2. Calculamos el centro visual del grupo de hijos biol√≥gicos
      const firstBio = hijosBio[0].getBoundingClientRect();
      const lastBio = hijosBio[hijosBio.length - 1].getBoundingClientRect();
      const centroBio = (firstBio.left + lastBio.right) / 2;

      // 3. Calculamos la diferencia respecto al padre superior
      const delta = centroPadres - centroBio;

      if (Math.abs(delta) > 1) {
          // Movemos TODO el bloque (incluyendo a la pareja), pero basado en la posici√≥n del hijo
          const currentTransform = new WebKitCSSMatrix(window.getComputedStyle(familyDiv).transform);
          familyDiv.style.transform = `translateX(${currentTransform.m41 + delta}px)`;
      }
  };

  // 1. ALINEAR HIJOS DEL PACIENTE
  const bloquesHijos = document.querySelectorAll('#hijos .nuclear-family');
  bloquesHijos.forEach(familyDiv => {
      const partnerId = familyDiv.dataset.partnerId;
      let centroPadres = 0;
      
      const patientNode = pacienteSlot.querySelector('.persona');
      if (!patientNode) return;
      const cPatient = getCenterX(patientNode);

      if (partnerId === 'single') {
          centroPadres = cPatient;
      } else {
          const partnerNode = document.querySelector(`.persona[data-id="${partnerId}"]`);
          if (partnerNode) {
              // L√≥gica de vecinos
              let neighborX = cPatient;
              if (partnerLeftSlot.contains(partnerNode)) {
                   const next = partnerNode.nextElementSibling;
                   if(next) neighborX = getCenterX(next);
              } else if (partnerRightSlot.contains(partnerNode)) {
                   const prev = partnerNode.previousElementSibling;
                   if(prev) neighborX = getCenterX(prev);
              }
              centroPadres = (getCenterX(partnerNode) + neighborX) / 2;
          } else {
              centroPadres = cPatient;
          }
      }
      moverFamilia(familyDiv, centroPadres);
  });

  // 2. ALINEAR NIETOS Y BISNIETOS
  descendantPartners.forEach(pareja => {
      const idBio = pareja.targetId; // Hijo Biol√≥gico
      const idPareja = pareja.id;    // Nuera/Yerno (clave del grupo)
      
      // Buscamos la familia nuclear que corresponde a esta pareja
      const familyDiv = document.querySelector(`.nuclear-family[data-partner-id="${idPareja}"]`);
      
      if (familyDiv) {
          // El "Padre Superior" es el centro entre el Hijo Biol√≥gico y su Pareja
          const nodoBio = document.querySelector(`.persona[data-id="${idBio}"]`);
          const nodoPareja = document.querySelector(`.persona[data-id="${idPareja}"]`);
          
          if (nodoBio && nodoPareja) {
              const c1 = getCenterX(nodoBio);
              const c2 = getCenterX(nodoPareja);
              const centroPadres = (c1 + c2) / 2;
              
              moverFamilia(familyDiv, centroPadres);
          }
      }
  });
}

/* --- NUEVA ALINEACI√ìN: CENTRAR HIJOS BAJO EL MATRIMONIO --- */
function alinearDescendenciaConPareja(containerId) {
  const container = document.getElementById(containerId);
  if (!container) return;

  const bloquesFamilia = container.querySelectorAll('.nuclear-family');

  bloquesFamilia.forEach(bloque => {
      // 1. IMPORTANTE: Reseteamos la posici√≥n antes de medir nada.
      // Esto elimina "fantasmas" de movimientos anteriores y nos da la posici√≥n real natural.
      bloque.style.transform = '';

      const idPareja = bloque.dataset.partnerId;
      
      // Si el grupo es 'single' (hijos de padre soltero/divorciado sin pareja actual visible),
      // deber√≠amos alinearlos con ese √∫nico padre.
      if (idPareja === 'single') {
         // L√≥gica opcional: si quieres alinear nietos de madre soltera, 
         // habr√≠a que buscar qui√©n es el padre/madre biol√≥gico de estos ni√±os.
         // Por simplicidad, nos enfocamos en el fallo actual (parejas).
         return; 
      }

      // Buscamos la pareja (nuera/yerno)
      const relacion = descendantPartners.find(r => r.id === idPareja);
      
      if (relacion) {
          const idBio = relacion.targetId; 
          const nodoBio = document.querySelector(`.persona[data-id="${idBio}"]`);
          const nodoPareja = document.querySelector(`.persona[data-id="${idPareja}"]`);

          if (nodoBio && nodoPareja) {
              // 2. D√ìNDE DEBEN ESTAR (META): Centro visual del Matrimonio
              const rBio = nodoBio.getBoundingClientRect();
              const rPareja = nodoPareja.getBoundingClientRect();
              const centroMatrimonio = (rBio.left + rBio.width/2 + rPareja.left + rPareja.width/2) / 2;

              // 3. D√ìNDE EST√ÅN AHORA (REALIDAD): Centro visual del bloque de nietos (tras el reset)
              // Medimos las tarjetas internas para ignorar m√°rgenes vac√≠os del div
              const hijosNodos = Array.from(bloque.querySelectorAll('.persona'));
              
              if (hijosNodos.length > 0) {
                  const firstChild = hijosNodos[0].getBoundingClientRect();
                  const lastChild = hijosNodos[hijosNodos.length - 1].getBoundingClientRect();
                  
                  // Centro visual real del grupo de hijos
                  const centroHijosActual = (firstChild.left + lastChild.right) / 2;

                  // 4. C√ÅLCULO FINAL
                  const delta = centroMatrimonio - centroHijosActual;

                  // Aplicamos la correcci√≥n exacta
                  bloque.style.transform = `translateX(${delta}px)`;
              }
          }
      }
  });
}

function alinearNivel(idNivel) {
  const container = document.getElementById(idNivel);
  const grupos = container.querySelectorAll('.ancestor-group');

  grupos.forEach(grupo => {
    // A qui√©n pertenece este grupo de ancestros (ID del hijo)
    const childId = grupo.dataset.childId; 
    
    // Buscar al hijo visualmente en todo el genograma
    const hijoNode = document.querySelector(`.persona[data-id="${childId}"]`);
    
    if (hijoNode) {
      const rectHijo = hijoNode.getBoundingClientRect();
      const rectGrupo = grupo.getBoundingClientRect();
      
      // Calcular centros
      const centerHijo = rectHijo.left + rectHijo.width / 2;
      const centerGrupo = rectGrupo.left + rectGrupo.width / 2;
      
      // Diferencia a mover
      const deltaX = centerHijo - centerGrupo;
      
      // Aplicar transformaci√≥n
      grupo.style.transform = `translateX(${deltaX}px)`;
    }
  });
}

/* ========== Renderizar ========== */
function render() {
  // 1. LIMPIEZA DE SLOTS
  // (Limpiamos los nuevos sub-contenedores)
  document.getElementById('bisabuelos-paternos').innerHTML = '';
  document.getElementById('bisabuelos-maternos').innerHTML = '';
  document.getElementById('abuelos-paternos').innerHTML = '';
  document.getElementById('abuelos-maternos').innerHTML = '';
  
  document.getElementById('nietos').innerHTML = '';
  document.getElementById('bisnietos').innerHTML = '';
  
  padreSlot.innerHTML = ''; madreSlot.innerHTML = '';
  partnerLeftSlot.innerHTML = ''; partnerRightSlot.innerHTML = '';
  hermanosLeft.innerHTML = ''; hermanosRight.innerHTML = '';
  pacienteSlot.innerHTML = ''; hijosSlot.innerHTML = '';

  // --- RENDERIZAR ANCESTROS (L√≥gica Dividida) ---
  
  // Funci√≥n auxiliar para crear grupos visuales
  function crearGruposAncestros(listaPersonas, slotDestino) {
      const slot = document.getElementById(slotDestino);
      const groups = {};
      
      // Agrupar por hijo (targetId)
      listaPersonas.forEach(p => {
          if(!groups[p.targetId]) groups[p.targetId] = [];
          groups[p.targetId].push(p);
      });

      Object.keys(groups).forEach(targetId => {
          const groupDiv = document.createElement('div');
          groupDiv.className = 'ancestor-group';
          groupDiv.style.cssText = "display:flex; gap:10px; align-items:center;";
          groupDiv.dataset.childId = targetId; 

          groups[targetId].forEach(p => groupDiv.appendChild(crearNodo(p)));
          slot.appendChild(groupDiv);
      });
  }

  // A. CLASIFICAR ABUELOS (Paternos vs Maternos)
  const abuelosPaternos = [];
  const abuelosMaternos = [];

  grandparents.forEach(abuelo => {
     // Si su hijo es MI PADRE -> Lado Paterno
     if (parents.father && abuelo.targetId === parents.father.id) {
         abuelosPaternos.push(abuelo);
     } 
     // Si su hijo es MI MADRE -> Lado Materno
     else if (parents.mother && abuelo.targetId === parents.mother.id) {
         abuelosMaternos.push(abuelo);
     }
     // Si el padre fue borrado pero qued√≥ el abuelo hu√©rfano, 
     // lo mandamos a paternos por defecto o lo ocultamos seg√∫n prefieras.
     // Aqu√≠ los dejamos en paternos para no perderlos visualmente.
     else {
         abuelosPaternos.push(abuelo); 
     }
  });

  crearGruposAncestros(abuelosPaternos, 'abuelos-paternos');
  crearGruposAncestros(abuelosMaternos, 'abuelos-maternos');

  // B. CLASIFICAR BISABUELOS (Lado Paterno vs Materno)
  // La l√≥gica es: ¬øEl hijo de este bisabuelo est√° en la lista de 'abuelosPaternos'?
  const idsAbuelosPaternos = abuelosPaternos.map(a => a.id);
  
  const bisabuelosPaternos = [];
  const bisabuelosMaternos = [];

  greatGrandparents.forEach(bis => {
      if (idsAbuelosPaternos.includes(bis.targetId)) {
          bisabuelosPaternos.push(bis);
      } else {
          bisabuelosMaternos.push(bis);
      }
  });

  crearGruposAncestros(bisabuelosPaternos, 'bisabuelos-paternos');
  crearGruposAncestros(bisabuelosMaternos, 'bisabuelos-maternos');

  /* --- RENDER PADRES (Con l√≥gica de "Empuje/Centrado") --- */
  // 1. Limpieza
  padreSlot.innerHTML = ''; 
  madreSlot.innerHTML = '';
  
  // 2. Renderizado
  if (parents.father) padreSlot.appendChild(crearNodo(parents.father));
  if (parents.mother) madreSlot.appendChild(crearNodo(parents.mother));

  // 3. LOGICA DE EMPUJE: Ocultar el slot vac√≠o para que el otro se centre
  // Si no hay padre, ocultamos su slot (display: none). Si hay, lo mostramos (block).
  padreSlot.style.display = parents.father ? 'block' : 'none';
  madreSlot.style.display = parents.mother ? 'block' : 'none';

  // Aseguramos estilos al contenedor padre para que el centrado funcione
  const padresContainer = document.getElementById('padres');
  padresContainer.style.display = 'flex';
  padresContainer.style.justifyContent = 'center'; // Clave: centra lo que quede visible
  padresContainer.style.gap = '40px'; // Espacio entre ellos cuando est√©n los dos

  if (!patient) {
    siblings.sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0)).forEach(s => hermanosRight.appendChild(crearNodo(s)));
    requestAnimationFrame(dibujarConexiones);
    return;
  }

  const sortedSiblings = [...siblings].sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0));
  const pAge = getNum(patient.edad) || 0;
  let insertIndex = Math.floor(sortedSiblings.length / 2);
  const maxSibAge = sortedSiblings.length ? (getNum(sortedSiblings[0].edad)||0) : null;
  const minSibAge = sortedSiblings.length ? (getNum(sortedSiblings[sortedSiblings.length-1].edad)||0) : null;

  if (sortedSiblings.length > 0) {
      if (maxSibAge !== null && pAge > maxSibAge) insertIndex = 0;
      else if (minSibAge !== null && pAge < minSibAge) insertIndex = sortedSiblings.length;
  }

  const sequence = [...sortedSiblings];
  sequence.splice(insertIndex, 0, patient);
  const leftSeq = sequence.slice(0, insertIndex);
  const rightSeq = sequence.slice(insertIndex + 1);

  leftSeq.forEach(s => hermanosLeft.appendChild(crearNodo(s)));
  pacienteSlot.appendChild(crearNodo(patient));
  rightSeq.forEach(s => hermanosRight.appendChild(crearNodo(s)));

  /* --- BLOQUE CORREGIDO: DISTRIBUCI√ìN DE PAREJAS Y EX-PAREJAS --- */
  if (partners.length > 0) {
  
    // 1. Separar pareja ACTUAL de las EX-parejas
    // Criterio: La 'actual' es la que NO tiene fecha fin, o la m√°s reciente si todas tienen fin.
    // Ordenamos por fecha para encontrar la m√°s reciente f√°cil
    let allSorted = ordenarParejasPorFecha([...partners], true); // Descendente (M√°s nuevo primero)
  
    // Asumimos que la primera de la lista ordenada es la "actual" o "√∫ltima relevante"
    let currentPartner = allSorted[0]; 
    let exPartners = allSorted.slice(1); // El resto son exes

    // 2. Determinar posici√≥n seg√∫n el sexo del PACIENTE
    // REGLA: Pareja actual va al lado opuesto del sexo del paciente, Exes van al lado contrario de la actual.
  
    const pacienteEsHombre = (patient.sexo === 'M');

    if (pacienteEsHombre) {
        // === PACIENTE HOMBRE ===
        // Pareja Actual (Mujer) -> A su DERECHA (Right Slot)
        partnerRightSlot.appendChild(crearNodo(currentPartner));

        // Ex-Parejas -> A su IZQUIERDA (Left Slot)
        // OJO: En el slot izquierdo (justify-flex-end), el √∫ltimo elemento a√±adido queda pegado al centro.
        // Queremos: [Ex Vieja] [Ex Nueva] [PACIENTE]
        // As√≠ que ordenamos Cronol√≥gicamente (Ascendente)
        let exesOrdenados = ordenarParejasPorFecha(exPartners, false); // false = ascendente (viejo a nuevo)
        exesOrdenados.forEach(ex => partnerLeftSlot.appendChild(crearNodo(ex)));
    } 
    else {
        // === PACIENTE MUJER ===
        // Pareja Actual (Hombre) -> A su IZQUIERDA (Left Slot)
        partnerLeftSlot.appendChild(crearNodo(currentPartner));

        // Ex-Parejas -> A su DERECHA (Right Slot)
        // En el slot derecho (justify-flex-start), el primer elemento queda pegado al centro.
        // Queremos: [PACIENTE] [Ex Nueva] [Ex Vieja]
        // As√≠ que ordenamos Descendente (Nuevo a Viejo)
        // (Ya lo tenemos en allSorted, pero filtramos solo los exes)
        let exesOrdenados = ordenarParejasPorFecha(exPartners, true); // true = descendente
        exesOrdenados.forEach(ex => partnerRightSlot.appendChild(crearNodo(ex)));
    }
  }

  // 1. Limpiamos el slot de hijos
  hijosSlot.innerHTML = '';

  // 2. Identificar el orden visual de las parejas (Izquierda -> Derecha)
  const leftPartnersIds = Array.from(partnerLeftSlot.querySelectorAll('.persona')).map(el => el.dataset.id);
  const rightPartnersIds = Array.from(partnerRightSlot.querySelectorAll('.persona')).map(el => el.dataset.id);
  
  // Creamos una lista de "IDs de grupos" en el orden que aparecen en pantalla
  // 'single' representa hijos solo del paciente (sin pareja conocida o seleccionada)
  const visualGroupsOrder = [...leftPartnersIds, 'single', ...rightPartnersIds];

/* --- FUNCI√ìN HELPER: Renderizar por Familias Nucleares --- */
function renderizarGeneracion(listaPersonas, contenedorId) {
    const contenedor = document.getElementById(contenedorId);
    contenedor.innerHTML = '';
    
    // Configuraci√≥n del contenedor principal de la generaci√≥n
    contenedor.style.display = 'flex';
    contenedor.style.justifyContent = 'center';
    contenedor.style.alignItems = 'flex-start';
    contenedor.style.gap = '80px'; // Separaci√≥n grande entre grupos de primos (familias distintas)

    // 1. AGRUPAR POR PAREJA DE PADRES (Para manejar primos/hermanastros correctamente)
    const gruposFamiliares = {};
    
    listaPersonas.forEach(p => {
        // Usamos el ID de la pareja (o 'single' si es soltero/desconocido) como clave
        const key = p.idPareja || 'single';
        if (!gruposFamiliares[key]) gruposFamiliares[key] = [];
        gruposFamiliares[key].push(p);
    });

    // 2. RENDERIZAR CADA FAMILIA NUCLEAR
    Object.keys(gruposFamiliares).forEach(partnerId => {
        const hijosFamilia = gruposFamiliares[partnerId];
        
        // A. Crear el Contenedor de la Familia (Nuclear Family Wrapper)
        const familyUnit = document.createElement('div');
        familyUnit.className = 'nuclear-family'; // CLASE CLAVE PARA LA ALINEACI√ìN
        familyUnit.dataset.partnerId = partnerId; // Metadato para encontrar a los padres
        
        familyUnit.style.display = 'flex';
        familyUnit.style.alignItems = 'center';
        
        // B. Crear los 3 Bloques Internos (Izquierda - Centro - Derecha)
        const leftPartners = document.createElement('div'); // Yernos
        leftPartners.style.display = 'flex';
        leftPartners.style.gap = '10px';
        leftPartners.style.marginRight = '40px'; // Separaci√≥n Parejas-Hermanos

        const siblingsCenter = document.createElement('div'); // Hermanos
        siblingsCenter.style.display = 'flex';
        siblingsCenter.style.gap = '10px'; // Hermanos pegaditos

        const rightPartners = document.createElement('div'); // Nueras
        rightPartners.style.display = 'flex';
        rightPartners.style.gap = '10px';
        rightPartners.style.marginLeft = '40px'; // Separaci√≥n Hermanos-Parejas

        // C. Ordenar y Distribuir
        // Ordenamos hermanos por edad
        hijosFamilia.sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0));

        hijosFamilia.forEach(hijo => {
            // 1. El hijo SIEMPRE va al centro
            siblingsCenter.appendChild(crearNodo(hijo));

            // 2. Su pareja va a los extremos
            const suPareja = descendantPartners.find(dp => dp.targetId === hijo.id);
            if (suPareja) {
                if (suPareja.sexo === 'M') {
                    // Pareja Hombre -> Izquierda
                    leftPartners.appendChild(crearNodo(suPareja));
                } else {
                    // Pareja Mujer -> Derecha
                    rightPartners.appendChild(crearNodo(suPareja));
                }
            }
        });

        // D. Ensamblar solo si hay contenido
        if (leftPartners.children.length > 0) familyUnit.appendChild(leftPartners);
        familyUnit.appendChild(siblingsCenter);
        if (rightPartners.children.length > 0) familyUnit.appendChild(rightPartners);

        // Agregar al contenedor general
        contenedor.appendChild(familyUnit);
    });
}

// EJECUTAR
renderizarGeneracion(children, 'hijos');
renderizarGeneracion(grandchildren, 'nietos');
renderizarGeneracion(greatGrandchildren, 'bisnietos');

// Renderizado final
requestAnimationFrame(() => {
    ajustarSeparacionAbuelos(); 
    ajustarSeparacionPadres();
    alinearGenograma(); 
    alinearPadresExactamente(); 
    
    // PASO 1: Mover Hijos (Padres de los nietos)
    alinearHijosConPadres(); 

    // Usamos setTimeout para asegurar que el navegador "pint√≥" el paso 1
    setTimeout(() => {
        
        // PASO 2: Mover Nietos (ahora que los padres est√°n quietos)
        alinearDescendenciaConPareja('nietos');     
        alinearDescendenciaConPareja('bisnietos');  

        // PASO 3: Dibujar l√≠neas
        requestAnimationFrame(() => {
            alinearAncestros(); 
            dibujarConexiones(); 
        });
        
    }, 0); // El 0 fuerza a que se ejecute al final de la pila de tareas de JS
  });
}

/* ========== DIBUJO DE CONEXIONES ========== */
function dibujarConexiones() {
  const width = Math.max(genogramaContainer.scrollWidth, genogramaContainer.offsetWidth);
  const height = Math.max(genogramaContainer.scrollHeight, genogramaContainer.offsetHeight);
  const rect = genogramaContainer.getBoundingClientRect(); 
  
  if (!stage) {
    stage = new Konva.Stage({ container: 'conexiones', width, height });
    layer = new Konva.Layer();
    stage.add(layer);
  } else {
    stage.width(width); 
    stage.height(height);
    layer.destroyChildren();
  }

  function centerOf(el) {
    if (!el) return null;
    const r = el.getBoundingClientRect();
    return {
      x: r.left + r.width / 2 - rect.left + genogramaContainer.scrollLeft,
      y: r.top + r.height / 2 - rect.top + genogramaContainer.scrollTop,
      top: r.top - rect.top + genogramaContainer.scrollTop,
      bottom: r.bottom - rect.top + genogramaContainer.scrollTop
    };
  }

  const fatherDom = padreSlot.querySelector('.persona');
  const motherDom = madreSlot.querySelector('.persona');
  const partnerDom = partnerLeftSlot.querySelector('.persona') || partnerRightSlot.querySelector('.persona');
  const patientDom = pacienteSlot.querySelector('.persona');
  
  const leftSibs = Array.from(hermanosLeft.querySelectorAll('.persona'));
  const rightSibs = Array.from(hermanosRight.querySelectorAll('.persona'));
  const hijosDom = Array.from(hijosSlot.querySelectorAll('.persona'));

  // 1) Padres (Generaci√≥n 0)
  let parentsMidX = null;
  let parentsYBar = null;

  if (fatherDom && motherDom) {
    // CASO AMBOS PADRES: Dibuja la "U"
    const cf = centerOf(fatherDom);
    const cm = centerOf(motherDom);
    
    const yBar = Math.max(cf.bottom, cm.bottom) + 15;
    parentsYBar = yBar;
    
    // Bajadas y Barra Horizontal (La U)
    layer.add(new Konva.Line({ points: [cf.x, cf.bottom, cf.x, yBar], stroke: 'black', strokeWidth: 2 }));
    layer.add(new Konva.Line({ points: [cm.x, cm.bottom, cm.x, yBar], stroke: 'black', strokeWidth: 2 }));
    layer.add(new Konva.Line({ points: [cf.x, yBar, cm.x, yBar], stroke: 'black', strokeWidth: 2 }));

    parentsMidX = (cf.x + cm.x) / 2;
  } 
  else if (fatherDom || motherDom) {
    // CASO MONOPARENTAL (Solo uno)
    // Al haber ocultado el slot vac√≠o en el render(), este nodo estar√° visualmente en el CENTRO.
    const single = centerOf(fatherDom || motherDom);
    parentsMidX = single.x;
    
    // IMPORTANTE: Hacemos que la "barra" sea un punto justo debajo del padre
    parentsYBar = single.bottom + 15; 
    
    // Dibujamos una peque√±a bajada vertical desde el padre hasta donde empezar√≠a la conexi√≥n a hijos
    layer.add(new Konva.Line({ points: [single.x, single.bottom, single.x, parentsYBar], stroke: 'black', strokeWidth: 2 }));
  }

  // 2) Padres -> Descendencia (CONECTAR A LA "U" DE ARRIBA)
  const allChildren = [...leftSibs, patientDom, ...rightSibs].filter(Boolean);
  
  if (parentsMidX !== null && allChildren.length) {
    const minTop = Math.min(...allChildren.map(s => centerOf(s).top));
    // La l√≠nea baja desde la barra de los padres hasta un poco antes de los hijos
    const yChildrenBar = (parentsYBar + minTop) / 2;

    // Bajada central desde la uni√≥n de padres
    layer.add(new Konva.Line({ points: [parentsMidX, parentsYBar, parentsMidX, yChildrenBar], stroke: 'black', strokeWidth: 2 }));

    // Barra horizontal sobre los hijos y bajadas individuales
    allChildren.forEach(s => {
      const c = centerOf(s);
      layer.add(new Konva.Line({ points: [c.x, c.top, c.x, yChildrenBar], stroke: 'black', strokeWidth: 2 }));
      layer.add(new Konva.Line({ points: [parentsMidX, yChildrenBar, c.x, yChildrenBar], stroke: 'black', strokeWidth: 2 }));
    });
  }

  // ===============================================
  // 3) MATRIMONIOS M√öLTIPLES (L√≥gica de Cadena / Eslabones)
  // ===============================================
  let marriageY = 0; 
  let activePartnerCenter = null; 

  // Obtenemos todos los nodos visuales de parejas
  const allPartnerNodes = [
      ...Array.from(partnerLeftSlot.querySelectorAll('.persona')),
      ...Array.from(partnerRightSlot.querySelectorAll('.persona'))
  ];

  if (patientDom && allPartnerNodes.length > 0) {
    const cPatient = centerOf(patientDom);
    
    // 1. CALCULAR ALTURA DE LA L√çNEA
    let maxBottom = cPatient.bottom;
    allPartnerNodes.forEach(n => {
        const c = centerOf(n);
        if (c.bottom > maxBottom) maxBottom = c.bottom;
    });
    marriageY = maxBottom + 25; 

    // 2. CREAR LISTA ORDENADA VISUALMENTE (De Izquierda a Derecha)
    // Esto es vital: Mezclamos al Paciente y a las Parejas en una sola lista
    // y los ordenamos por coordenada X. As√≠ sabemos qui√©n est√° al lado de qui√©n.
    let visualChain = [];
    
    // A) Agregamos Paciente
    visualChain.push({ 
        type: 'patient', 
        x: cPatient.x, 
        center: cPatient, 
        id: patient.id 
    });
    
    // B) Agregamos Parejas
    allPartnerNodes.forEach(node => {
        const c = centerOf(node);
        visualChain.push({ 
            type: 'partner', 
            x: c.x, 
            center: c, 
            id: node.dataset.id 
        });
    });

    // C) Ordenamos por posici√≥n X (Izquierda -> Derecha)
    visualChain.sort((a, b) => a.x - b.x);

    // 3. DIBUJAR LA L√çNEA BASE HORIZONTAL
    // Conectamos desde el primero de la izquierda hasta el √∫ltimo de la derecha
    const startX = visualChain[0].x;
    const endX = visualChain[visualChain.length - 1].x;
    
    layer.add(new Konva.Line({ 
        points: [startX, marriageY, endX, marriageY], 
        stroke: 'black', strokeWidth: 2 
    }));

    // Buscamos d√≥nde qued√≥ el paciente en la lista ordenada
    const patientIndex = visualChain.findIndex(n => n.type === 'patient');

    // 4. PROCESAR CADA NODO PARA S√çMBOLOS Y TALLOS
    visualChain.forEach((node, index) => {
        // A. Tallo Vertical (Bajada desde la persona a la l√≠nea)
        layer.add(new Konva.Line({ 
            points: [node.x, node.center.y, node.x, marriageY], 
            stroke: 'black', strokeWidth: 2 
        }));

        // Si es el paciente, no lleva s√≠mbolos de relaci√≥n sobre s√≠ mismo
        if (node.type === 'patient') return;

        // B. L√≥gica de "El Vecino" (Neighbor) para calcular el centro del s√≠mbolo
        // Si el nodo est√° a la izquierda del paciente, su "siguiente" es el de la derecha (index + 1)
        // Si el nodo est√° a la derecha del paciente, su "siguiente" es el de la izquierda (index - 1)
        let neighbor = null;

        if (index < patientIndex) {
            neighbor = visualChain[index + 1]; // Mira hacia la derecha (hacia el paciente)
        } else {
            neighbor = visualChain[index - 1]; // Mira hacia la izquierda (hacia el paciente)
        }

        // C. Calcular coordenadas del S√≠mbolo
        // Exactamente en el medio entre este nodo y su vecino
        const midX = (node.x + neighbor.x) / 2;

        const pData = partners.find(p => p.id === node.id);
        if (pData) {
            const h = 8; 
            const symbolConfig = { stroke: 'black', strokeWidth: 2 };
            const tipo = pData.tipoRelacion;

            // Dibujar s√≠mbolos (//, /, etc)
            if (tipo === 'separacion') {
                layer.add(new Konva.Line({ points: [midX - 4, marriageY + h, midX + 4, marriageY - h], ...symbolConfig }));
            } else if (tipo === 'divorcio') {
                layer.add(new Konva.Line({ points: [midX - 6, marriageY + h, midX - 2, marriageY - h], ...symbolConfig }));
                layer.add(new Konva.Line({ points: [midX + 2, marriageY + h, midX + 6, marriageY - h], ...symbolConfig }));
            } else if (tipo === 'reconciliacion') {
                layer.add(new Konva.Line({ points: [midX - 8, marriageY - h, midX + 8, marriageY + h], ...symbolConfig }));
            }

            // Tallo punteado si es "pareja de hecho"
            if (tipo === 'de_hecho') {
                 // Truco visual: pintamos l√≠nea blanca encima y luego punteada negra
                 layer.add(new Konva.Line({ points: [node.x, node.center.y, node.x, marriageY], stroke: 'white', strokeWidth: 2 }));
                 layer.add(new Konva.Line({ points: [node.x, node.center.y, node.x, marriageY], stroke: 'black', strokeWidth: 2, dash: [10, 5] }));
            }

            // Detectar "pareja activa" para conectar hijos luego
            if (!activePartnerCenter && (tipo === 'normal' || tipo === 'de_hecho')) {
                activePartnerCenter = node.center;
            }
        }
    });
    
    // Fallback: Si todas son ex-parejas, usamos al paciente para que salgan los hijos
    // (Opcional, depende de tu l√≥gica de negocio)
  }

  // ===============================================
  // 4) HIJOS (Sincronizado con la l√≥gica de vecinos)
  // ===============================================
  if (patientDom && children.length > 0) {
    const cPatient = centerOf(patientDom);
    
    // Agrupar hijos
    const gruposHijos = {};
    gruposHijos['single'] = []; 
    partners.forEach(p => gruposHijos[p.id] = []); 

    children.forEach(child => {
       const pid = child.idPareja;
       if (pid && gruposHijos[pid]) gruposHijos[pid].push(child);
       else gruposHijos['single'].push(child);
    });

    Object.keys(gruposHijos).forEach(partnerId => {
        const misHijosData = gruposHijos[partnerId];
        if (misHijosData.length === 0) return;

        // A. Nodos visuales de los hijos
        const misHijosNodes = misHijosData.map(d => 
            hijosSlot.querySelector(`.persona[data-id="${d.id}"]`)
        ).filter(Boolean);
        
        if (misHijosNodes.length === 0) return;

        // B. Calcular ORIGEN del Tallo (startX)
        let startX, startY;
        
        if (partnerId === 'single') {
            startX = cPatient.x;
            startY = cPatient.bottom;
        } else {
            // Buscamos a la pareja
            const partnerNode = partnerLeftSlot.querySelector(`.persona[data-id="${partnerId}"]`) || 
                                partnerRightSlot.querySelector(`.persona[data-id="${partnerId}"]`);
            
            if (partnerNode) {
                const cPartner = centerOf(partnerNode);
                
                /* --- CORRECCI√ìN L√ìGICA DE VECINOS (Igual que en alinearGenograma) --- */
                // Para que la l√≠nea baje EXACTAMENTE donde pusimos a los hijos
                let neighborX = cPatient.x; // Por defecto el vecino es el paciente

                if (partnerLeftSlot.contains(partnerNode)) {
                    // Si est√° a la izquierda, su vecino hacia el centro es el "siguiente"
                    const next = partnerNode.nextElementSibling;
                    if (next) neighborX = centerOf(next).x;
                } 
                else if (partnerRightSlot.contains(partnerNode)) {
                    // Si est√° a la derecha, su vecino hacia el centro es el "anterior"
                    const prev = partnerNode.previousElementSibling;
                    if (prev) neighborX = centerOf(prev).x;
                }

                // El tallo baja del promedio entre la PAREJA y su VECINO
                startX = (cPartner.x + neighborX) / 2;
                /* ------------------------------------------------------------- */

                startY = marriageY; 
            } else {
                startX = cPatient.x;
                startY = cPatient.bottom;
            }
        }

        // C. Calcular la Barra Horizontal
        const minChildTop = Math.min(...misHijosNodes.map(h => centerOf(h).top));
        // Altura de la barra
        const yEnd = startY + (minChildTop - startY) * 0.6; 

        // L√≠mites de los hijos
        const allChildX = misHijosNodes.map(h => centerOf(h).x);
        let minBarX = Math.min(...allChildX);
        let maxBarX = Math.max(...allChildX);

        // Estiramiento de seguridad (Por si la f√≠sica los movi√≥ un poco extra)
        if (startX < minBarX) minBarX = startX;
        if (startX > maxBarX) maxBarX = startX;

        // D. Dibujar Tallo
        layer.add(new Konva.Line({ points: [startX, startY, startX, yEnd], stroke: 'black', strokeWidth: 2 }));

        // E. Dibujar Barra Horizontal
        layer.add(new Konva.Line({ points: [minBarX, yEnd, maxBarX, yEnd], stroke: 'black', strokeWidth: 2 }));

        // F. Bajadas individuales
        for (let i = 0; i < misHijosNodes.length; i++) {
            const hNode = misHijosNodes[i];
            const hData = misHijosData[i];
            const ch = centerOf(hNode);
            const tipo = hData.tipoHijo || 'biologico';

            // Gemelos
            let esParejaGemelos = false;
            if (i < misHijosNodes.length - 1) {
                const nextNode = misHijosNodes[i+1];
                const nextData = misHijosData[i+1];
                if (nextData && (tipo === 'mellizo' || tipo === 'gemelo') && (nextData.tipoHijo === tipo)) {
                    esParejaGemelos = true;
                    const chNext = centerOf(nextNode);
                    const midX = (ch.x + chNext.x) / 2;
                    
                    layer.add(new Konva.Line({ points: [midX, yEnd, ch.x, ch.top], stroke: 'black', strokeWidth: 2 }));
                    layer.add(new Konva.Line({ points: [midX, yEnd, chNext.x, chNext.top], stroke: 'black', strokeWidth: 2 }));
                    
                    if (tipo === 'gemelo') {
                         const barY = (yEnd + ch.top) / 2 + 5;
                         const x1 = midX + (ch.x - midX) * 0.5;
                         const x2 = midX + (chNext.x - midX) * 0.5;
                         layer.add(new Konva.Line({ points: [x1, barY, x2, barY], stroke: 'black', strokeWidth: 2 }));
                    }
                    i++; 
                    continue;
                }
            }
            
            // Normal
            if (!esParejaGemelos) {
                 const configLinea = { 
                    stroke: 'black', strokeWidth: 2,
                    dash: (tipo === 'adoptado') ? [5, 5] : [] 
                 };
                 layer.add(new Konva.Line({ points: [ch.x, yEnd, ch.x, ch.top], ...configLinea }));
            }
        }
    });
  }

  /* ========== NUEVAS CONEXIONES: ANCESTROS ========== */
  function conectarAncestros(ancestorList, childList, generationY_Top, generationY_Bottom) {
      // childList puede ser parents, grandparents, etc.
      // Iteramos sobre los "hijos" para buscar a sus "padres" en la ancestorList
      
      let childNodes = [];
      // Normalizar childList (puede ser objeto {father, mother} o array)
      if (Array.isArray(childList)) childNodes = childList;
      else {
          if (childList.father) childNodes.push(childList.father);
          if (childList.mother) childNodes.push(childList.mother);
      }

      childNodes.forEach(childData => {
          // Buscar nodos visuales
          const childNode = document.querySelector(`.persona[data-id="${childData.id}"]`);
          if (!childNode) return;
          const cChild = centerOf(childNode);

          // Buscar padres de este nodo en la lista de ancestros
          const misPadres = ancestorList.filter(p => p.targetId === childData.id);
          
          if (misPadres.length === 0) return;

          // Obtener centros de los padres visuales
          const parentCenters = misPadres.map(p => {
              const node = document.querySelector(`.persona[data-id="${p.id}"]`);
              return node ? centerOf(node) : null;
          }).filter(Boolean);

          if (parentCenters.length === 0) return;

          // REGLA: 1 Padre = L√≠nea vertical. 2 Padres = U Invertida
          if (parentCenters.length === 1) {
               // L√≠nea vertical directa
               const cp = parentCenters[0];
               layer.add(new Konva.Line({ points: [cp.x, cp.bottom, cChild.x, cChild.top], stroke: 'black', strokeWidth: 2 }));
          } else {
               // Ordenar izquierda derecha
               parentCenters.sort((a,b) => a.x - b.x);
               const p1 = parentCenters[0]; // Izq
               const p2 = parentCenters[parentCenters.length - 1]; // Der (por si hay poligamia, tomamos extremos)

               const midY = (p1.bottom + cChild.top) / 2;
               
               // L√≠nea horizontal entre padres (la U)
               layer.add(new Konva.Line({ points: [p1.x, p1.bottom + 10, p2.x, p2.bottom + 10], stroke: 'black', strokeWidth: 2 }));
               
               // Bajadas peque√±as de padres a la U
               layer.add(new Konva.Line({ points: [p1.x, p1.bottom, p1.x, p1.bottom + 10], stroke: 'black', strokeWidth: 2 }));
               layer.add(new Konva.Line({ points: [p2.x, p2.bottom, p2.x, p2.bottom + 10], stroke: 'black', strokeWidth: 2 }));

               // Bajada central al hijo
               const centerX = (p1.x + p2.x) / 2;
               layer.add(new Konva.Line({ points: [centerX, p1.bottom + 10, cChild.x, cChild.top], stroke: 'black', strokeWidth: 2 }));
          }
      });
  }

  // 1. Conectar Bisabuelos -> Abuelos
  conectarAncestros(greatGrandparents, grandparents, 0, 0);
  
  // 2. Conectar Abuelos -> Padres
  conectarAncestros(grandparents, parents, 0, 0);

  /* ========== CONEXI√ìN RAMAS DESCENDIENTES (TIPO TUBER√çA) ========== */
  function conectarRamaDescendiente(listaHijos, listaNietos) {
      // ITERAMOS SOBRE LAS PAREJAS (RELACIONES) EXISTENTES
      // En lugar de buscar en los nietos, buscamos en los "matrimonios" de la generaci√≥n anterior.
      descendantPartners.forEach(pareja => {
          // Datos del matrimonio
          const idBio = pareja.targetId; // El hijo de sangre (ej. hijo del paciente)
          const idPareja = pareja.id;    // La pareja externa (ej. nuera)

          // 1. Buscar los nodos visuales de los PADRES (Hijo + Nuera)
          const nodoBio = document.querySelector(`.persona[data-id="${idBio}"]`);
          const nodoPareja = document.querySelector(`.persona[data-id="${idPareja}"]`);
          
          // Si alguno no est√° dibujado, saltamos
          if (!nodoBio || !nodoPareja) return;

          // 2. Buscar a los HIJOS (Nietos) que pertenezcan a este padre biol√≥gico
          // (Asumimos que son hijos de esta pareja actual)
          const misHijos = listaNietos.filter(n => n.targetId === idBio);
          
          if (misHijos.length === 0) return;

          // 3. Obtener centros visuales
          const cBio = centerOf(nodoBio);
          const cPareja = centerOf(nodoPareja);

          // A. PUNTO DE INICIO (Centro del matrimonio - la "U")
          const startX = (cBio.x + cPareja.x) / 2;
          const startY = Math.max(cBio.bottom, cPareja.bottom) + 20; // +20 coincide con la altura de la U que dibujas en conectarParejasDescendientes

          // B. CALCULAR L√çMITES DE LOS HIJOS (NIETOS)
          const centrosHijos = misHijos.map(n => {
              const node = document.querySelector(`.persona[data-id="${n.id}"]`);
              return node ? centerOf(node) : null;
          }).filter(Boolean);

          if (centrosHijos.length === 0) return;

          const minChildX = Math.min(...centrosHijos.map(c => c.x));
          const maxChildX = Math.max(...centrosHijos.map(c => c.x));
          const childTop = centrosHijos[0].top;

          // C. DIBUJAR L√çNEAS (Tuber√≠a)
          
          // 1. Tallo Vertical desde Padres hacia abajo
          const midY = (startY + childTop) / 2;
          layer.add(new Konva.Line({ points: [startX, startY, startX, midY], stroke: 'black', strokeWidth: 2 }));

          // 2. Barra Horizontal sobre los hijos (si hay m√°s de uno o est√°n desplazados)
          const barLeft = Math.min(startX, minChildX);
          const barRight = Math.max(startX, maxChildX);
          
          layer.add(new Konva.Line({ points: [barLeft, midY, barRight, midY], stroke: 'black', strokeWidth: 2 }));

          // 3. Bajadas a cada hijo
          centrosHijos.forEach(c => {
              layer.add(new Konva.Line({ points: [c.x, midY, c.x, c.top], stroke: 'black', strokeWidth: 2 }));
          });
      });
  }

  // Ejecutar para las generaciones correspondientes
  conectarRamaDescendiente(children, grandchildren);       // Hijos -> Nietos
  conectarRamaDescendiente(grandchildren, greatGrandchildren); // Nietos -> Bisnietos

  /* ========== CONEXI√ìN PAREJAS (CORCHETE "U") ========== */
function conectarParejasDescendientes(listaDescendientes) {
    listaDescendientes.forEach(persona => {
        const suPareja = descendantPartners.find(dp => dp.targetId === persona.id);
        if (!suPareja) return;

        const nodoPersona = document.querySelector(`.persona[data-id="${persona.id}"]`);
        const nodoPareja = document.querySelector(`.persona[data-id="${suPareja.id}"]`);

        if (nodoPersona && nodoPareja) {
            const c1 = centerOf(nodoPersona);
            const c2 = centerOf(nodoPareja);

            // Altura de la barra horizontal (Base de la U)
            // 20px debajo de las personas
            const yBar = Math.max(c1.bottom, c2.bottom) + 20;

            // 1. Bajada Vertical desde la Persona
            layer.add(new Konva.Line({ 
                points: [c1.x, c1.bottom, c1.x, yBar], 
                stroke: 'black', strokeWidth: 2 
            }));

            // 2. Bajada Vertical desde la Pareja
            layer.add(new Konva.Line({ 
                points: [c2.x, c2.bottom, c2.x, yBar], 
                stroke: 'black', strokeWidth: 2 
            }));

            // 3. Barra Horizontal Larga (El puente)
            layer.add(new Konva.Line({ 
                points: [c1.x, yBar, c2.x, yBar], 
                stroke: 'black', strokeWidth: 2 
            }));
            
            // Opcional: Si quieres un peque√±o indicador en el centro de la relaci√≥n
            // const midX = (c1.x + c2.x) / 2;
            // layer.add(new Konva.Circle({ x: midX, y: yBar, radius: 3, fill: 'black' }));
        }
    });
}

  // Ejecutar para las generaciones correspondientes
  conectarRamaDescendiente(children, grandchildren);       // Hijos -> Nietos
  conectarRamaDescendiente(grandchildren, greatGrandchildren); // Nietos -> Bisnietos

  // --- NUEVO: DIBUJAR LAS "U" DE LAS PAREJAS ---
  conectarParejasDescendientes(children);
  conectarParejasDescendientes(grandchildren);
  conectarParejasDescendientes(greatGrandchildren);

  layer.draw();
}

/* ========== Eventos ========== */
agregarPacienteBtn.onclick = () => {
  const nombre = document.getElementById('nombre').value.trim();
  if (!nombre) return alert('Ingresa nombre');
  patient = { id:uid(), nombre, apellido:document.getElementById('apellido').value, edad:document.getElementById('edad').value, sexo:document.getElementById('sexo').value, esPaciente:true };
  formPaciente.style.display='none'; render();
};

function abrirMenu(x,y){ menu.style.left=x+'px'; menu.style.top=y+'px'; menu.classList.remove('oculto'); }
function cerrarMenu(){ menu.classList.add('oculto'); seleccionado=null; }
menuAgregarBtn.onclick = ()=>{ cerrarMenu(); abrirFormFamiliar(); };
menuEliminarBtn.onclick = ()=>{ if(seleccionado) eliminarSeleccionado(); cerrarMenu(); };

function abrirFormFamiliar(){ 
  formFamiliar.classList.remove('oculto'); 
  // Disparamos el evento change para configurar estados correctos al abrir
  famRolSelect.dispatchEvent(new Event('change'));
  actualizarCamposPorEstado();
}
function cerrarFormFamiliar(){ formFamiliar.classList.add('oculto'); }

/* --- NUEVA FUNCI√ìN: CARGAR DATOS PARA EDITAR --- */
function cargarDatosEdicion() {
  if (!seleccionado) return;
  
  // Rellenar campos b√°sicos
  document.getElementById('famNombre').value = seleccionado.nombre || '';
  document.getElementById('famApellido').value = seleccionado.apellido || '';
  document.getElementById('famEdad').value = seleccionado.edad || '';
  document.getElementById('famSexo').value = seleccionado.sexo || 'M';
  document.getElementById('famEstado').value = seleccionado.estado || 'vivo';
  document.getElementById('famSalud').value = seleccionado.salud || 'ninguno';
  document.getElementById('famLgtb').checked = seleccionado.lgtb || false;
  document.getElementById('relAnioInicio').value = seleccionado.relAnioInicio || '';
  document.getElementById('relAnioFin').value = seleccionado.relAnioFin || '';

  // Rellenar selects espec√≠ficos
  if (seleccionado.tipoRelacion) document.getElementById('famTipoRelacion').value = seleccionado.tipoRelacion;
  if (seleccionado.tipoHijo) document.getElementById('famTipoHijo').value = seleccionado.tipoHijo;

  // Intentar preseleccionar el Rol y el Target (Vinculaci√≥n)
  const rolSelect = document.getElementById('famRol');
  
  // Si guardamos el rol en la creaci√≥n, lo usamos. Si no, bloqueamos para evitar errores.
  if (seleccionado.rol) {
      rolSelect.value = seleccionado.rol;
      // Disparamos el evento para que aparezcan los campos de vinculaci√≥n (targetId)
      rolSelect.dispatchEvent(new Event('change'));
      
      // Una vez generada la lista de targetId, seleccionamos el correcto
      const targetInput = document.getElementById('famTargetId');
      if (seleccionado.targetId) targetInput.value = seleccionado.targetId;
      if (seleccionado.idPareja && seleccionado.rol === 'hijo') targetInput.value = seleccionado.idPareja;
  }
  
  // Actualizar UI (bloqueo de campos por estado, etc.)
  toggleDivorcioOption();
  actualizarCamposPorEstado();
}

// Evento del bot√≥n Modificar
menuModificarBtn.onclick = () => {
    // CORRECCI√ìN: No llamamos a cerrarMenu() aqu√≠ porque eso pone seleccionado = null.
    // En su lugar, ocultamos el men√∫ manualmente para conservar la persona seleccionada.
    menu.classList.add('oculto'); 
    
    if (seleccionado) {
        modoEdicion = true; // Activamos modo edici√≥n
        document.querySelector('#formFamiliar h4').textContent = "Modificar Familiar"; 
        document.getElementById('guardarFamiliarBtn').textContent = "Guardar Cambios";
        
        abrirFormFamiliar();
        cargarDatosEdicion(); // Llenamos el formulario
    }
};

// Ajuste al bot√≥n "Agregar" para resetear el modo edici√≥n
const originalMenuAgregar = menuAgregarBtn.onclick;
menuAgregarBtn.onclick = () => {
    modoEdicion = false; // Modo creaci√≥n
    document.querySelector('#formFamiliar h4').textContent = "Agregar familiar";
    document.getElementById('guardarFamiliarBtn').textContent = "Agregar";
    
    cerrarMenu();
    abrirFormFamiliar();
    // Limpieza extra por si acaso
    document.getElementById('famNombre').value = '';
    document.getElementById('famApellido').value = '';
};

/* --- C. BOT√ìN GUARDAR (MODIFICADO PARA EDITAR) --- */
guardarFamiliarBtn.onclick = () => {
  // 1. CAPTURA DE TODOS LOS INPUTS
  const nomInput = document.getElementById('famNombre');
  const apeInput = document.getElementById('famApellido');
  const edadInput = document.getElementById('famEdad');
  const sexoInput = document.getElementById('famSexo');
  const rolInput = document.getElementById('famRol');
  const estadoInput = document.getElementById('famEstado');
  const saludInput = document.getElementById('famSalud');
  const lgtbInput = document.getElementById('famLgtb');
  const tipoRelacionInput = document.getElementById('famTipoRelacion'); 
  const tipoHijoInput = document.getElementById('famTipoHijo');
  const targetIdInput = document.getElementById('famTargetId');
  
  const anioInicioInput = document.getElementById('relAnioInicio');
  const anioFinInput = document.getElementById('relAnioFin');

  // Validaciones
  const estado = estadoInput.value;
  const nom = nomInput.value.trim();
  const permiteSinNombre = ['embarazo', 'aborto_esp', 'aborto_prov'].includes(estado);

  if (!nom && !permiteSinNombre) return alert("Por favor ingresa un nombre");

  const getYearVal = (input) => {
    const val = parseInt(input.value.trim());
    return (Number.isFinite(val) && val > 1800) ? val : null;
  };

  // 2. L√ìGICA DE EDICI√ìN
  if (modoEdicion && seleccionado) {
      // Actualizamos solo las propiedades del objeto existente
      seleccionado.nombre = nom;
      seleccionado.apellido = apeInput.value;
      seleccionado.edad = edadInput.value;
      seleccionado.sexo = sexoInput.value;
      seleccionado.estado = estado;
      seleccionado.salud = saludInput.value;
      seleccionado.lgtb = lgtbInput.checked;
      seleccionado.tipoRelacion = tipoRelacionInput.value;
      seleccionado.tipoHijo = tipoHijoInput.value;
      seleccionado.relAnioInicio = getYearVal(anioInicioInput);
      seleccionado.relAnioFin = getYearVal(anioFinInput);
      
      // Intentamos actualizar targetId y rol solo si no rompe la estructura
      // (Nota: Cambiar roles complejos requerir√≠a mover de array, aqu√≠ solo actualizamos datos)
      if(targetIdInput.value) seleccionado.targetId = targetIdInput.value;
      if(targetIdInput.value && seleccionado.rol === 'hijo') seleccionado.idPareja = targetIdInput.value;

  } else {
      // 3. L√ìGICA DE CREACI√ìN (NUEVO)
      const p = { 
        id: uid(), 
        nombre: nom || '', 
        apellido: apeInput.value, 
        edad: edadInput.value, 
        sexo: sexoInput.value,
        estado: estado, 
        salud: saludInput.value,
        lgtb: lgtbInput.checked,
        tipoRelacion: tipoRelacionInput.value,
        tipoHijo: tipoHijoInput.value,
        targetId: targetIdInput.value, 
        rol: rolInput.value, // IMPORTANTE: Guardamos el rol para poder editarlo luego
        relAnioInicio: getYearVal(anioInicioInput),
        relAnioFin: getYearVal(anioFinInput)
      };

      const rol = rolInput.value;
      if (rol === 'bisabuelo') greatGrandparents.push(p);
      else if (rol === 'abuelo') grandparents.push(p);
      else if (rol === 'padre') { 
        if (p.sexo === 'M') parents.father = p; else parents.mother = p; 
      }
      else if (rol === 'pareja') {
        const idx = partners.findIndex(x => x.id === p.id);
        if (idx >= 0) partners[idx] = p;
        partners.push(p);
      }
      else if (rol === 'hermano') siblings.push(p);
      else if (rol === 'hijo') {
          p.idPareja = targetIdInput.value; 
          children.push(p);
      }
      else if (rol === 'nieto') grandchildren.push(p);
      else if (rol === 'bisnieto') greatGrandchildren.push(p);
      else if (rol === 'pareja_descendiente') descendantPartners.push(p);
  }

  // 4. LIMPIEZA Y RESET
  nomInput.value = ''; apeInput.value = ''; edadInput.value = '';
  estadoInput.value = 'vivo'; saludInput.value = 'ninguno';
  lgtbInput.checked = false;
  tipoRelacionInput.value = 'normal'; tipoHijoInput.value = 'biologico';
  anioInicioInput.value = ''; anioFinInput.value = '';
  
  cerrarFormFamiliar(); 
  render();
};

function eliminarSeleccionado(){
  if(!seleccionado) return;
  const id = seleccionado.id;

  // 1. Paciente
  if(patient && patient.id===id) { patient=null; formPaciente.style.display='block'; }
  
  // 2. Padres
  if(parents.father && parents.father.id===id) parents.father=null;
  if(parents.mother && parents.mother.id===id) parents.mother=null;
  
  // 3. Listas Simples (Filtrar ID)
  partners = partners.filter(p => p.id !== id);
  siblings = siblings.filter(s => s.id !== id);
  children = children.filter(c => c.id !== id);
  
  // 4. NUEVAS LISTAS (Agregado para que funcione borrar abuelos/nietos)
  grandparents = grandparents.filter(p => p.id !== id);
  greatGrandparents = greatGrandparents.filter(p => p.id !== id);
  grandchildren = grandchildren.filter(p => p.id !== id);
  greatGrandchildren = greatGrandchildren.filter(p => p.id !== id);
  descendantPartners = descendantPartners.filter(p => p.id !== id);

  seleccionado = null;
  render();
}

window.addEventListener('resize', () => {
  if (stage) { stage.destroy(); stage=null; layer=null; }
  alinearGenograma();
  requestAnimationFrame(() => dibujarConexiones());
});

/* ========== INICIALIZACI√ìN Y CARGA DE DATOS ========== */

async function iniciarGenograma() {
  const params = new URLSearchParams(window.location.search);
  const pNombre = params.get('nombre');
  const pApellido = params.get('apellido') || '';
  const pEdad = params.get('edad') || 0;
  const pSexo = params.get('sexo') || 'M';

  if (pNombre) {
    try {
      // 1. Intentamos buscar en la Base de Datos
      const respuesta = await fetch(`http://localhost:3001/api/obtener-genograma?nombre=${encodeURIComponent(pNombre)}&apellido=${encodeURIComponent(pApellido)}`);
      
      if (respuesta.ok) {
        const familiaDB = await respuesta.json();
        console.log("Datos cargados de DB:", familiaDB);
        reconstruirDesdeDB(familiaDB); // Funci√≥n nueva (ver abajo)
      } else {
        // 2. Si no existe (404), creamos uno nuevo con los datos de la URL
        console.log("Paciente nuevo, creando desde URL...");
        crearPacienteDesdeURL(pNombre, pApellido, pEdad, pSexo);
      }
    } catch (error) {
      console.error("Error al conectar con API:", error);
      // Fallback: Crear localmente si falla la API
      crearPacienteDesdeURL(pNombre, pApellido, pEdad, pSexo);
    }
  }
  
  // Renderizar al final de todo
  render();
}

function crearPacienteDesdeURL(nombre, apellido, edad, sexo) {
  patient = { 
      id: uid(), // Generamos ID nuevo
      nombre: nombre, 
      apellido: apellido, 
      edad: edad, 
      sexo: sexo, 
      esPaciente: true 
  };
  formPaciente.style.display = 'none';
}

function reconstruirDesdeDB(familia) {
  // Limpiamos listas actuales
  parents = { father: null, mother: null };
  partners = []; siblings = []; children = [];
  grandparents = []; greatGrandparents = [];
  grandchildren = []; greatGrandchildren = [];
  descendantPartners = [];

  // Mapeamos los datos de DB al formato del Frontend
  familia.forEach(dbItem => {
      // Reconstruimos el objeto tal cual lo usa tu script visual
      const persona = {
          id: dbItem.tempIdFrontend, // ¬°Muy importante! Usar el ID original visual
          nombre: dbItem.nombre,
          apellido: dbItem.apellido,
          edad: dbItem.edad,
          sexo: dbItem.sexo,
          estado: dbItem.estado,
          salud: dbItem.salud,
          lgtb: dbItem.esLgtb,
          rol: dbItem.rol,
          // Datos relacionales
          targetId: dbItem.targetId,
          idPareja: dbItem.idPareja,
          tipoRelacion: dbItem.tipoRelacion,
          tipoHijo: dbItem.tipoHijo,
          relAnioInicio: dbItem.relAnioInicio,
          relAnioFin: dbItem.relAnioFin
      };

      if (dbItem.rol === 'paciente') {
          persona.esPaciente = true;
          patient = persona;
          formPaciente.style.display = 'none';
      } 
      else if (dbItem.rol === 'padre') {
          if (persona.sexo === 'M') parents.father = persona;
          else parents.mother = persona;
      }
      else if (dbItem.rol === 'pareja') partners.push(persona);
      else if (dbItem.rol === 'hermano') siblings.push(persona);
      else if (dbItem.rol === 'hijo') children.push(persona);
      else if (dbItem.rol === 'abuelo') grandparents.push(persona);
      else if (dbItem.rol === 'bisabuelo') greatGrandparents.push(persona);
      else if (dbItem.rol === 'nieto') grandchildren.push(persona);
      else if (dbItem.rol === 'bisnieto') greatGrandchildren.push(persona);
      else if (dbItem.rol === 'pareja_descendiente') descendantPartners.push(persona);
  });
}

// Ejecutamos al cargar
iniciarGenograma();

render();

/* ========== L√ìGICA DE EXPORTACI√ìN A PDF ========== */
const btnExportarPDF = document.getElementById('btnExportarPDF');

btnExportarPDF.addEventListener('click', async () => {
  // 1. Feedback visual al usuario
  const textoOriginal = btnExportarPDF.textContent;
  btnExportarPDF.textContent = "Generando PDF...";
  btnExportarPDF.disabled = true;

  try {
    const { jsPDF } = window.jspdf;
    
    // Seleccionamos el contenedor exacto que tiene el dibujo y las tarjetas
    const element = document.querySelector('.genograma-container');

    // 2. Usar html2canvas para crear una imagen del DOM
    // scale: 2 mejora la calidad del texto y las l√≠neas
    const canvas = await html2canvas(element, {
      scale: 2, 
      useCORS: true, // Ayuda si hay im√°genes externas (aunque no parece ser el caso)
      backgroundColor: "#ffffff", // Fondo blanco obligatorio para PDF
      logging: false,
      windowWidth: element.scrollWidth, // Asegura capturar todo si hay scroll
      windowHeight: element.scrollHeight
    });

    // 3. Configurar el PDF (Horizontal/Landscape es mejor para genogramas)
    const pdf = new jsPDF('l', 'mm', 'a4'); // 'l' = landscape
    
    // Dimensiones de A4 Landscape
    const pdfWidth = 297; 
    const pdfHeight = 210;
    const margen = 10; // Margen de 10mm

    // Obtener dimensiones de la imagen generada
    const imgData = canvas.toDataURL('image/png');
    const imgProps = pdf.getImageProperties(imgData);
    
    // 4. Calcular ratio para ajustar la imagen a la p√°gina sin deformar
    const pdfContentWidth = pdfWidth - (margen * 2);
    const pdfContentHeight = pdfHeight - (margen * 2);

    const ratioWidth = pdfContentWidth / imgProps.width;
    const ratioHeight = pdfContentHeight / imgProps.height;
    
    // Usamos el ratio menor para que quepa entero
    const ratio = Math.min(ratioWidth, ratioHeight);
    
    const newWidth = imgProps.width * ratio;
    const newHeight = imgProps.height * ratio;

    // 5. Centrar la imagen en el PDF
    const x = (pdfWidth - newWidth) / 2;
    const y = (pdfHeight - newHeight) / 2;

    pdf.addImage(imgData, 'PNG', x, y, newWidth, newHeight);
    
    // 6. Guardar
    pdf.save('genograma.pdf');

  } catch (err) {
    console.error("Error exportando PDF:", err);
    alert("Hubo un error al generar el PDF. Revisa la consola para m√°s detalles.");
  } finally {
    // Restaurar bot√≥n
    btnExportarPDF.textContent = textoOriginal;
    btnExportarPDF.disabled = false;
  }
});

/* ========== GUARDADO EN BASE DE DATOS ========== */
const btnGuardarDB = document.getElementById('btnGuardarDB');

btnGuardarDB.addEventListener('click', async () => {
  // 1. Validar que haya algo que guardar
  if (!patient) {
    alert("No hay un paciente principal creado. Nada que guardar.");
    return;
  }

  // 2. Empaquetar todos los datos en un solo objeto JSON
  const datosGenograma = {
    patient: patient,
    parents: parents,
    partners: partners,
    siblings: siblings,
    children: children,
    grandparents: grandparents,
    greatGrandparents: greatGrandparents,
    grandchildren: grandchildren,
    greatGrandchildren: greatGrandchildren,
    descendantPartners: descendantPartners
  };

  // 3. Feedback visual (cambiar texto del bot√≥n)
  const textoOriginal = btnGuardarDB.textContent;
  btnGuardarDB.textContent = "Guardando...";
  btnGuardarDB.disabled = true;

  try {
    // 4. Enviar los datos al backend usando FETCH
    // Aseg√∫rate de que el puerto (3001) coincida con el que sale en tu terminal al iniciar el servidor
const respuesta = await fetch('http://localhost:3001/api/guardar-genograma', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(datosGenograma)
    });

    if (respuesta.ok) {
      alert("‚úÖ Genograma guardado correctamente en la base de datos.");
    } else {
      alert("‚ùå Error al guardar en el servidor.");
      console.error("Error servidor:", await respuesta.text());
    }

  } catch (error) {
    console.error("Error de conexi√≥n:", error);
    alert("‚ùå Error de conexi√≥n con la base de datos.");
  } finally {
    // Restaurar bot√≥n
    btnGuardarDB.textContent = textoOriginal;
    btnGuardarDB.disabled = false;
  }
});

</script>
</body>
</html>