<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Genograma</title>
  <link rel="stylesheet" href="../style/style_geno.css">
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
</head>
<body>
  <h1>Genograma</h1>
  <button id="btnGuardarDB" class="btn-save">游 Guardar Cambios</button>

  <div class="form-wrapper" id="formPaciente">
    <h3>Agregar paciente</h3>
    <label>Nombre: <input type="text" id="nombre" /></label>
    <label>Apellido: <input type="text" id="apellido" /></label>
    <label>Edad: <input type="number" id="edad" min="0" /></label>
    <label>Sexo:
      <select id="sexo">
        <option value="M">Masculino</option>
        <option value="F">Femenino</option>
      </select>
    </label>
    <div style="margin-top:8px">
      <button id="agregarPaciente">Agregar paciente</button>
    </div>
  </div>

  <div class="genograma-container">
    <div id="conexiones"></div>

    <div class="genograma">
      <div class="fila padres" id="padres">
        <div class="parent-slot" id="padre-slot"></div>
        <div class="parent-slot" id="madre-slot"></div>
      </div>

      <div class="fila middle-row" id="middle">
        <div class="pareja-slot" id="partner-left-slot"></div>

        <div class="center-block" id="center-block">
          <div class="hermanos left" id="hermanos-left"></div>
          <div class="paciente-slot" id="paciente-slot"></div>
          <div class="hermanos right" id="hermanos-right"></div>
        </div>

        <div class="pareja-slot" id="partner-right-slot"></div>
      </div>

      <div class="fila hijos" id="hijos"></div>
    </div>
  </div>

  <div id="formFamiliar" class="modal oculto" role="dialog" aria-hidden="true">
    <div class="modal-inner">
      <h4>Agregar familiar</h4>
      <label>Nombre: <input type="text" id="famNombre" /></label>
      <label>Apellido: <input type="text" id="famApellido" /></label>
      <label>Edad: <input type="number" id="famEdad" min="0" /></label>
      <label>Sexo:
        <select id="famSexo">
          <option value="M">Masculino</option>
          <option value="F">Femenino</option>
        </select>
      </label>
      <label>Rol:
        <select id="famRol">
          <option value="padre">Padre/Madre</option>
          <option value="pareja">Pareja</option>
          <option value="hermano">Hermano/a</option>
          <option value="hijo">Hijo/a</option>
        </select>
      </label>
      
      <div id="divTipoHijo" style="display:none; margin-top:8px;">
        <label>Tipo de Hijo:
          <select id="famTipoHijo" style="width:100%">
            <option value="biologico">Biol칩gico (Normal)</option>
            <option value="adoptado">Adoptado (L칤nea Punteada)</option>
            <option value="mellizo">Mellizo (Dizig칩tico)</option>
            <option value="gemelo">Gemelo (Monocig칩tico/Id칠ntico)</option>
          </select>
        </label>
      </div>

      <div id="divSelectPareja" style="display:none; margin-top:8px;">
        <label>Otro Progenitor (Pareja):
          <select id="famIdPareja" style="width:100%">
            </select>
        </label>
      </div>

      <label>Salud / Problemas:
        <select id="famSalud" style="width:100%">
          <option value="ninguno">Ninguno</option>
          <option value="abuso">Abuso Alcohol/Drogas</option>
          <option value="ingreso">Ingreso / Recuperaci칩n</option> <option value="sospecha">Sospecha de Abuso</option>
          <option value="mental">Prob. Mentales / Psicol칩gicos</option>
          <option value="ambos">Comorbilidad (Abuso + Mental)</option>
        </select>
      </label>
      <label>Estado Vital:
        <select id="famEstado" style="width:100%">
          <option value="vivo">Vivo</option>
          <option value="fallecido">Fallecido</option>
          <option value="embarazo">Embarazo</option>
          <option value="neonato_x">Muerte al nacer</option>
          <option value="aborto_esp">Aborto Espont치neo</option>
          <option value="aborto_prov">Aborto Provocado</option>
        </select>
      </label>
      <label style="display:inline-flex; align-items:center; gap:5px; margin-top:5px;">
        <input type="checkbox" id="famLgtb" /> 
        LGTBIQ+
      </label>
      <div id="lblDivorcio" style="display:none; margin-top:8px;">
        <label>Estado de la Relaci칩n:
          <select id="famTipoRelacion" style="width:100%">
            <option value="normal">Relaci칩n Vigente (Matrimonio)</option>
            <option value="de_hecho">Pareja de hecho / Amante</option>
            <option value="separacion">Separaci칩n</option>
            <option value="divorcio">Divorcio</option>
            <option value="reconciliacion">Reconciliaci칩n tras Divorcio</option> </select>
        </label>
      </div>
      <div id="bloqueFechasRelacion" style="display:none; margin-top:8px; padding:10px; background:#f0f0f0; border-radius:4px;">
        <label style="font-weight:bold;">Cronolog칤a de la Relaci칩n:</label>
        <div style="display:flex; gap:10px; margin-top:5px;">
          <label style="flex:1;">A침o Inicio: 
            <input type="number" id="relAnioInicio" placeholder="Ej: 1990" min="1900" max="2030" style="width:100%">
          </label>
          <label style="flex:1;">A침o Fin (si aplica): 
            <input type="number" id="relAnioFin" placeholder="Ej: 2005" min="1900" max="2030" style="width:100%">
          </label>
        </div>
        <small style="color:#666;">Necesario para ordenar relaciones m칰ltiples.</small>
      </div>

      <div class="modal-actions" style="margin-top:8px;">
        <button id="guardarFamiliarBtn">Agregar</button>
        <button type="button" onclick="cerrarFormFamiliar()">Cancelar</button>
      </div>
    </div>
  </div>

  <div id="menuAcciones" class="menu-acciones oculto">
    <button id="menuAgregar">Agregar familiar</button>
    <button id="menuEliminar">Eliminar</button>
    <button onclick="cerrarMenu()">Cerrar</button>
  </div>

<script>
/* ========== Modelo de datos ========== */
function uid(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,8); }

let patient = null;
let parents = { father: null, mother: null };
let partners = []; // Ahora es una lista vac칤a
let siblings = [];
let children = [];
let seleccionado = null;

/* ========== Selectores DOM ========== */
const padreSlot = document.getElementById('padre-slot');
const madreSlot = document.getElementById('madre-slot');
const partnerLeftSlot = document.getElementById('partner-left-slot');
const partnerRightSlot = document.getElementById('partner-right-slot');
const hermanosLeft = document.getElementById('hermanos-left');
const hermanosRight = document.getElementById('hermanos-right');
const pacienteSlot = document.getElementById('paciente-slot');
const hijosSlot = document.getElementById('hijos');
const genogramaContainer = document.querySelector('.genograma-container');
const middleRow = document.getElementById('middle'); 
const hijosRow = document.getElementById('hijos'); 

const formPaciente = document.getElementById('formPaciente');
const agregarPacienteBtn = document.getElementById('agregarPaciente');
const menu = document.getElementById('menuAcciones');
const menuAgregarBtn = document.getElementById('menuAgregar');
const menuEliminarBtn = document.getElementById('menuEliminar');
const formFamiliar = document.getElementById('formFamiliar');
const guardarFamiliarBtn = document.getElementById('guardarFamiliarBtn');

const famRolSelect = document.getElementById('famRol');

/* --- MODIFICAR: Funci칩n para mostrar/ocultar opciones de PAREJA --- */
const divRelacion = document.getElementById('lblDivorcio');
const tipoRelacionInput = document.getElementById('famTipoRelacion');
// NUEVO SELECTOR:
const bloqueFechasRelacion = document.getElementById('bloqueFechasRelacion');

function toggleDivorcioOption() {
  const esPareja = (famRolSelect.value === 'pareja');

  if (esPareja) {
    divRelacion.style.display = 'block';
    // NUEVO: Mostrar fechas
    bloqueFechasRelacion.style.display = 'block';
  } else {
    divRelacion.style.display = 'none';
    // NUEVO: Ocultar fechas y resetear
    bloqueFechasRelacion.style.display = 'none';
    tipoRelacionInput.value = 'normal';
    document.getElementById('relAnioInicio').value = '';
    document.getElementById('relAnioFin').value = '';
  }
}

/* --- MODIFICAR: Listener unificado para cambios de ROL --- */
famRolSelect.addEventListener('change', () => {
  const rol = famRolSelect.value;
  
  // 1. L칩gica de Pareja
  toggleDivorcioOption();
  
  // 2. L칩gica de Estados
  filtrarOpcionesEstado();

  // 3. L칩gica de Hijos (Tipo y Pareja)
  const divTipoHijo = document.getElementById('divTipoHijo');
  const divSelectPareja = document.getElementById('divSelectPareja');
  const selectPareja = document.getElementById('famIdPareja');
  const tipoHijoInput = document.getElementById('famTipoHijo');
  
  if (rol === 'hijo') {
    divTipoHijo.style.display = 'block';
    divSelectPareja.style.display = 'block';

    // Llenar select con parejas actuales
    selectPareja.innerHTML = '<option value="">-- Desconocido / Solo Paciente --</option>';
    partners.forEach(p => {
      const option = document.createElement('option');
      option.value = p.id;
      // Muestra nombre o "Pareja" si no tiene nombre
      option.textContent = p.nombre ? p.nombre : 'Pareja sin nombre'; 
      selectPareja.appendChild(option);
    });

  } else {
    divTipoHijo.style.display = 'none';
    divSelectPareja.style.display = 'none';
    tipoHijoInput.value = 'biologico';
    selectPareja.innerHTML = '';
  }
});


/* --- L칍GICA: FILTRAR ESTADOS SEG칔N ROL --- */
/* --- L칍GICA: FILTRAR ESTADOS SEG칔N ROL --- */
const famEstadoSelect = document.getElementById('famEstado');

function filtrarOpcionesEstado() {
  const rol = famRolSelect.value;
  // Estados que queremos que sean exclusivos para el rol 'hijo'
  const estadosInfantiles = ['embarazo', 'neonato_x', 'aborto_esp', 'aborto_prov'];
  
  for (let i = 0; i < famEstadoSelect.options.length; i++) {
    const opt = famEstadoSelect.options[i];
    
    // Si la opci칩n actual es una de las "infantiles"
    if (estadosInfantiles.includes(opt.value)) {
      // SOLO mostramos si el rol es exactamente 'hijo'
      if (rol === 'hijo') {
        opt.hidden = false; 
        opt.disabled = false; 
        opt.style.display = 'block';
      } else {
        // Para cualquier otro rol (padre, pareja, hermano), se oculta
        opt.hidden = true; 
        opt.disabled = true; 
        opt.style.display = 'none';
      }
    }
  }

  // Validaci칩n de seguridad:
  // Si el usuario ten칤a seleccionado "aborto" y cambia el rol a "Padre",
  // el valor quedar칤a inv치lido. Forzamos el cambio a "vivo".
  const valorActual = famEstadoSelect.value;
  if (estadosInfantiles.includes(valorActual) && rol !== 'hijo') {
    famEstadoSelect.value = 'vivo';
    // Llamamos a actualizarCampos para que habilite de nuevo drogas/lgtb si estaban bloqueados
    actualizarCamposPorEstado();
  }
}

/* --- A. L칍GICA DE BLOQUEO (Sin drogas/LGTB para fetos) --- */
function actualizarCamposPorEstado() {
  const estado = famEstadoSelect.value;
  const saludSelect = document.getElementById('famSalud');
  const lgtbCheck = document.getElementById('famLgtb');
  const estadosInfantiles = ['embarazo', 'neonato_x', 'aborto_esp', 'aborto_prov'];
  
  if (estadosInfantiles.includes(estado)) {
    saludSelect.value = 'ninguno';
    lgtbCheck.checked = false;
    saludSelect.disabled = true;
    lgtbCheck.disabled = true;
    saludSelect.parentElement.style.opacity = '0.5';
    lgtbCheck.parentElement.style.opacity = '0.5';
  } else {
    saludSelect.disabled = false;
    lgtbCheck.disabled = false;
    saludSelect.parentElement.style.opacity = '1';
    lgtbCheck.parentElement.style.opacity = '1';
  }
}

famEstadoSelect.addEventListener('change', actualizarCamposPorEstado);

/* ========== Utilidades ========== */
const getNum = v => { const n = parseInt(v); return Number.isFinite(n) ? n : null; };
function getCenterX(el) { const r = el.getBoundingClientRect(); return r.left + r.width / 2; }

// Funci칩n para ordenar un array de parejas cronol칩gicamente.
function ordenarParejasPorFecha(listaParejas, ordenDescendente = true) {
  return listaParejas.sort((a, b) => {
    // Usamos 0 como valor por defecto si no se introdujo a침o, para evitar errores
    const inicioA = a.relAnioInicio || 0;
    const inicioB = b.relAnioInicio || 0;

    if (ordenDescendente) {
        // Orden: M치s Reciente -> M치s Antiguo (Ej: 2020, 2010, 1990)
        // Esto se usa para las parejas que est치n "m치s cerca" del sujeto central.
        return inicioB - inicioA; 
    } else {
        // Orden: M치s Antiguo -> M치s Reciente (Ej: 1990, 2010, 2020)
        return inicioA - inicioB;
    }
  });
}

/* ========== Crear nodo persona ========== */
function crearNodo(persona) {
  const div = document.createElement('div');
  
  let clases = 'persona ' + (persona.sexo === 'M' ? 'hombre' : 'mujer');
  if (persona.esPaciente) clases += ' paciente';
  
  if (persona.estado === 'fallecido') clases += ' fallecido';
  else if (persona.estado === 'embarazo') clases += ' embarazo';
  else if (persona.estado === 'neonato_x') clases += ' neonato-x';
  else if (persona.estado === 'aborto_esp') clases += ' aborto-esp';
  else if (persona.estado === 'aborto_prov') clases += ' aborto-prov';

  if (persona.salud && persona.salud !== 'ninguno') clases += ' patron-' + persona.salud; 
  if (persona.lgtb) clases += ' lgtb'; 
  
  div.className = clases;
  div.dataset.id = persona.id;

  if (persona.lgtb) {
    const tri = document.createElement('div');
    tri.className = 'simbolo-lgtb';
    div.appendChild(tri);
  }

  const sinTexto = ['aborto_esp', 'aborto_prov']; 
  if (!sinTexto.includes(persona.estado)) {
    const nombre = document.createElement('div');
    nombre.className = 'nombre';
    nombre.textContent = persona.nombre + (persona.apellido ? (' ' + persona.apellido) : '');

    const edad = document.createElement('div');
    edad.className = 'edad';
    edad.textContent = persona.edad ? (persona.edad + ' a침os') : '';

    div.appendChild(nombre);
    div.appendChild(edad);
  }
  
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    seleccionado = persona;
    abrirMenu(e.pageX, e.pageY);
  });
  
  return div;
}

/* ========== Konva Config ========== */
let stage = null;
let layer = null;

/* --- ALINEACI칍N INTELIGENTE (Detecta vecinos para no solapar hijos) --- */
function alinearGenograma() {
  // 1. LIMPIEZA INICIAL
  middleRow.style.transform = '';
  hijosRow.style.transform = '';
  document.querySelectorAll('.child-group').forEach(g => g.style.transform = '');
  document.querySelectorAll('.middle-row .persona').forEach(p => p.style.transform = '');

  const patientDom = pacienteSlot.querySelector('.persona');
  if (!patientDom) return;

  const cPatient = getCenterX(patientDom);

  // --- A. Recopilar datos ---
  const groups = Array.from(document.querySelectorAll('.child-group'));
  if (groups.length === 0) return;

  let groupData = groups.map(group => {
    const rect = group.getBoundingClientRect();
    const partnerId = group.dataset.partnerId;
    let targetX = 0;

    if (partnerId === 'single') {
        targetX = cPatient;
    } else {
        const partnerDom = document.querySelector(`.persona[data-id="${partnerId}"]`);
        
        if (partnerDom) {
            const cPartner = getCenterX(partnerDom);
            
            // --- NUEVO: L칍GICA DE VECINOS ---
            // En lugar de ir siempre hasta el Paciente, buscamos qui칠n est치 al lado
            // para poner a los hijos en el hueco libre inmediato.
            let obstacleDom = null;

            // Verificamos si la pareja est치 en el slot Izquierdo o Derecho
            if (partnerLeftSlot.contains(partnerDom)) {
                // IZQUIERDA: El vecino hacia el centro es el "siguiente hermano" en el DOM
                // (Porque el orden es: Ex1, Ex2, ... Paciente)
                obstacleDom = partnerDom.nextElementSibling;
                // Si no hay m치s ex-parejas a la derecha, el obst치culo es el Paciente
                if (!obstacleDom) obstacleDom = patientDom;
            } 
            else if (partnerRightSlot.contains(partnerDom)) {
                // DERECHA: El vecino hacia el centro es el "hermano anterior"
                // (Porque el orden es: Paciente ... Pareja1, Pareja2)
                obstacleDom = partnerDom.previousElementSibling;
                // Si no hay nadie antes, el obst치culo es el Paciente
                if (!obstacleDom) obstacleDom = patientDom;
            }

            // Calculamos el centro del obst치culo (Ex2 o Paciente)
            const cObstacle = obstacleDom ? getCenterX(obstacleDom) : cPatient;

            // EL CENTRO SEGURO: Promedio entre la Pareja y su Vecino Inmediato
            targetX = (cPartner + cObstacle) / 2;

        } else {
            targetX = cPatient;
        }
    }

    return {
        node: group,
        partnerId: partnerId,
        rect: rect,
        width: rect.width,
        currentX: rect.left + rect.width / 2, 
        idealX: targetX,      
        finalX: targetX       
    };
  });

  // Ordenar visualmente para la f칤sica
  groupData.sort((a, b) => a.idealX - b.idealX);

  // --- B. Resolver Colisiones (Igual que antes) ---
  const GAP = 40; 

  for (let step = 0; step < 3; step++) {
      for (let i = 0; i < groupData.length - 1; i++) {
          const g1 = groupData[i];
          const g2 = groupData[i + 1];

          const g1Right = g1.finalX + g1.width / 2;
          const g2Left = g2.finalX - g2.width / 2;

          if (g1Right + GAP > g2Left) {
              const overlap = (g1Right + GAP) - g2Left;
              g1.finalX -= overlap / 2;
              g2.finalX += overlap / 2;
          }
      }
  }

  // --- C. Aplicar Movimientos ---
  groupData.forEach(d => {
      // 1. Mover Hijos
      const shiftChildren = d.finalX - d.currentX;
      d.node.style.transform = `translateX(${shiftChildren}px)`;

      // 2. Mover Pareja (Efecto Palanca)
      if (d.partnerId !== 'single') {
          const deltaCenter = d.finalX - d.idealX; 
          if (Math.abs(deltaCenter) > 0.1) {
             const partnerNode = document.querySelector(`.persona[data-id="${d.partnerId}"]`);
             if (partnerNode) {
                 // Nota: Aqu칤 usamos un factor 1.5 o 2 suave, porque ahora el punto de referencia
                 // no es fijo (el vecino tambi칠n puede moverse). Usar 2 suele funcionar bien.
                 const partnerShift = deltaCenter * 2;
                 partnerNode.style.transform = `translateX(${partnerShift}px)`;
             }
          }
      }
  });
}

// Funci칩n auxiliar simple si no la tienes global
function getCenterX(el) { 
    const r = el.getBoundingClientRect(); 
    return r.left + r.width / 2; 
}

/* ========== Renderizar ========== */
function render() {
  padreSlot.innerHTML = ''; madreSlot.innerHTML = '';
  partnerLeftSlot.innerHTML = ''; partnerRightSlot.innerHTML = '';
  hermanosLeft.innerHTML = ''; hermanosRight.innerHTML = '';
  pacienteSlot.innerHTML = ''; hijosSlot.innerHTML = '';

  if (parents.father) padreSlot.appendChild(crearNodo(parents.father));
  if (parents.mother) madreSlot.appendChild(crearNodo(parents.mother));

  if (!patient) {
    siblings.sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0)).forEach(s => hermanosRight.appendChild(crearNodo(s)));
    requestAnimationFrame(dibujarConexiones);
    return;
  }

  const sortedSiblings = [...siblings].sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0));
  const pAge = getNum(patient.edad) || 0;
  let insertIndex = Math.floor(sortedSiblings.length / 2);
  const maxSibAge = sortedSiblings.length ? (getNum(sortedSiblings[0].edad)||0) : null;
  const minSibAge = sortedSiblings.length ? (getNum(sortedSiblings[sortedSiblings.length-1].edad)||0) : null;

  if (sortedSiblings.length > 0) {
      if (maxSibAge !== null && pAge > maxSibAge) insertIndex = 0;
      else if (minSibAge !== null && pAge < minSibAge) insertIndex = sortedSiblings.length;
  }

  const sequence = [...sortedSiblings];
  sequence.splice(insertIndex, 0, patient);
  const leftSeq = sequence.slice(0, insertIndex);
  const rightSeq = sequence.slice(insertIndex + 1);

  leftSeq.forEach(s => hermanosLeft.appendChild(crearNodo(s)));
  pacienteSlot.appendChild(crearNodo(patient));
  rightSeq.forEach(s => hermanosRight.appendChild(crearNodo(s)));

  /* --- BLOQUE CORREGIDO: DISTRIBUCI칍N DE PAREJAS Y EX-PAREJAS --- */
  if (partners.length > 0) {
  
    // 1. Separar pareja ACTUAL de las EX-parejas
    // Criterio: La 'actual' es la que NO tiene fecha fin, o la m치s reciente si todas tienen fin.
    // Ordenamos por fecha para encontrar la m치s reciente f치cil
    let allSorted = ordenarParejasPorFecha([...partners], true); // Descendente (M치s nuevo primero)
  
    // Asumimos que la primera de la lista ordenada es la "actual" o "칰ltima relevante"
    let currentPartner = allSorted[0]; 
    let exPartners = allSorted.slice(1); // El resto son exes

    // 2. Determinar posici칩n seg칰n el sexo del PACIENTE
    // REGLA: Pareja actual va al lado opuesto del sexo del paciente, Exes van al lado contrario de la actual.
  
    const pacienteEsHombre = (patient.sexo === 'M');

    if (pacienteEsHombre) {
        // === PACIENTE HOMBRE ===
        // Pareja Actual (Mujer) -> A su DERECHA (Right Slot)
        partnerRightSlot.appendChild(crearNodo(currentPartner));

        // Ex-Parejas -> A su IZQUIERDA (Left Slot)
        // OJO: En el slot izquierdo (justify-flex-end), el 칰ltimo elemento a침adido queda pegado al centro.
        // Queremos: [Ex Vieja] [Ex Nueva] [PACIENTE]
        // As칤 que ordenamos Cronol칩gicamente (Ascendente)
        let exesOrdenados = ordenarParejasPorFecha(exPartners, false); // false = ascendente (viejo a nuevo)
        exesOrdenados.forEach(ex => partnerLeftSlot.appendChild(crearNodo(ex)));
    } 
    else {
        // === PACIENTE MUJER ===
        // Pareja Actual (Hombre) -> A su IZQUIERDA (Left Slot)
        partnerLeftSlot.appendChild(crearNodo(currentPartner));

        // Ex-Parejas -> A su DERECHA (Right Slot)
        // En el slot derecho (justify-flex-start), el primer elemento queda pegado al centro.
        // Queremos: [PACIENTE] [Ex Nueva] [Ex Vieja]
        // As칤 que ordenamos Descendente (Nuevo a Viejo)
        // (Ya lo tenemos en allSorted, pero filtramos solo los exes)
        let exesOrdenados = ordenarParejasPorFecha(exPartners, true); // true = descendente
        exesOrdenados.forEach(ex => partnerRightSlot.appendChild(crearNodo(ex)));
    }
  }

  // 1. Limpiamos el slot de hijos
  hijosSlot.innerHTML = '';

  // 2. Identificar el orden visual de las parejas (Izquierda -> Derecha)
  const leftPartnersIds = Array.from(partnerLeftSlot.querySelectorAll('.persona')).map(el => el.dataset.id);
  const rightPartnersIds = Array.from(partnerRightSlot.querySelectorAll('.persona')).map(el => el.dataset.id);
  
  // Creamos una lista de "IDs de grupos" en el orden que aparecen en pantalla
  // 'single' representa hijos solo del paciente (sin pareja conocida o seleccionada)
  const visualGroupsOrder = [...leftPartnersIds, 'single', ...rightPartnersIds];

  // 3. Crear los contenedores (child-group) en el orden correcto
  visualGroupsOrder.forEach(groupId => {
    // Filtramos los hijos que pertenecen a este grupo
    let hijosDelGrupo = [];
    
    if (groupId === 'single') {
        // Hijos sin idPareja o cuyo ID no est치 en la lista de parejas visuales
        hijosDelGrupo = children.filter(c => !c.idPareja || (!leftPartnersIds.includes(c.idPareja) && !rightPartnersIds.includes(c.idPareja)));
    } else {
        hijosDelGrupo = children.filter(c => c.idPareja === groupId);
    }

    // Si no hay hijos en este grupo, no creamos el div (para no ocupar espacio invisible)
    if (hijosDelGrupo.length === 0) return;

    // Ordenamos hijos por edad
    hijosDelGrupo.sort((a,b) => (getNum(b.edad)||0) - (getNum(a.edad)||0));

    // Creamos el contenedor del grupo
    const groupDiv = document.createElement('div');
    groupDiv.className = 'child-group';
    groupDiv.dataset.partnerId = groupId; // Guardamos de qui칠n son para alinearlos luego

    // Agregamos los nodos de los hijos al grupo
    hijosDelGrupo.forEach(h => groupDiv.appendChild(crearNodo(h)));

    // Agregamos el grupo al slot principal
    hijosSlot.appendChild(groupDiv);
  });

  // Renderizado final
  requestAnimationFrame(() => {
    alinearGenograma(); // <--- Esto ahora ser치 crucial
    requestAnimationFrame(() => {
      dibujarConexiones(); 
    });
  });
}

/* ========== DIBUJO DE CONEXIONES ========== */
function dibujarConexiones() {
  const width = Math.max(genogramaContainer.scrollWidth, genogramaContainer.offsetWidth);
  const height = Math.max(genogramaContainer.scrollHeight, genogramaContainer.offsetHeight);
  const rect = genogramaContainer.getBoundingClientRect(); 
  
  if (!stage) {
    stage = new Konva.Stage({ container: 'conexiones', width, height });
    layer = new Konva.Layer();
    stage.add(layer);
  } else {
    stage.width(width); 
    stage.height(height);
    layer.destroyChildren();
  }

  function centerOf(el) {
    if (!el) return null;
    const r = el.getBoundingClientRect();
    return {
      x: r.left + r.width / 2 - rect.left + genogramaContainer.scrollLeft,
      y: r.top + r.height / 2 - rect.top + genogramaContainer.scrollTop,
      top: r.top - rect.top + genogramaContainer.scrollTop,
      bottom: r.bottom - rect.top + genogramaContainer.scrollTop
    };
  }

  const fatherDom = padreSlot.querySelector('.persona');
  const motherDom = madreSlot.querySelector('.persona');
  const partnerDom = partnerLeftSlot.querySelector('.persona') || partnerRightSlot.querySelector('.persona');
  const patientDom = pacienteSlot.querySelector('.persona');
  
  const leftSibs = Array.from(hermanosLeft.querySelectorAll('.persona'));
  const rightSibs = Array.from(hermanosRight.querySelectorAll('.persona'));
  const hijosDom = Array.from(hijosSlot.querySelectorAll('.persona'));

  // 1) Padres
  if (fatherDom && motherDom) {
    const cf = centerOf(fatherDom), cm = centerOf(motherDom);
    layer.add(new Konva.Line({ points: [cf.x, cf.y, cm.x, cm.y], stroke: 'black', strokeWidth: 2 }));
  }

  // 2) Padres -> Descendencia
  const allChildren = [...leftSibs, patientDom, ...rightSibs].filter(Boolean);
  if ((fatherDom || motherDom) && allChildren.length) {
    let originX, originY;
    if (fatherDom && motherDom) {
      const cf = centerOf(fatherDom), cm = centerOf(motherDom);
      originX = (cf.x + cm.x) / 2;
      originY = (cf.y + cm.y) / 2; 
    } else {
      const single = centerOf(fatherDom || motherDom);
      originX = single.x; originY = single.bottom;
    }

    const minTop = Math.min(...allChildren.map(s => centerOf(s).top));
    const yBar = (originY + minTop) / 2 + 10;

    layer.add(new Konva.Line({ points: [originX, originY, originX, yBar], stroke: 'black', strokeWidth: 2 }));

    allChildren.forEach(s => {
      const c = centerOf(s);
      layer.add(new Konva.Line({ points: [c.x, c.top, c.x, yBar], stroke: 'black', strokeWidth: 2 }));
      layer.add(new Konva.Line({ points: [originX, yBar, c.x, yBar], stroke: 'black', strokeWidth: 2 }));
    });
  }

  // ===============================================
  // 3) MATRIMONIOS M칔LTIPLES (L칩gica de Cadena / Eslabones)
  // ===============================================
  let marriageY = 0; 
  let activePartnerCenter = null; 

  // Obtenemos todos los nodos visuales de parejas
  const allPartnerNodes = [
      ...Array.from(partnerLeftSlot.querySelectorAll('.persona')),
      ...Array.from(partnerRightSlot.querySelectorAll('.persona'))
  ];

  if (patientDom && allPartnerNodes.length > 0) {
    const cPatient = centerOf(patientDom);
    
    // 1. CALCULAR ALTURA DE LA L칈NEA
    let maxBottom = cPatient.bottom;
    allPartnerNodes.forEach(n => {
        const c = centerOf(n);
        if (c.bottom > maxBottom) maxBottom = c.bottom;
    });
    marriageY = maxBottom + 25; 

    // 2. CREAR LISTA ORDENADA VISUALMENTE (De Izquierda a Derecha)
    // Esto es vital: Mezclamos al Paciente y a las Parejas en una sola lista
    // y los ordenamos por coordenada X. As칤 sabemos qui칠n est치 al lado de qui칠n.
    let visualChain = [];
    
    // A) Agregamos Paciente
    visualChain.push({ 
        type: 'patient', 
        x: cPatient.x, 
        center: cPatient, 
        id: patient.id 
    });
    
    // B) Agregamos Parejas
    allPartnerNodes.forEach(node => {
        const c = centerOf(node);
        visualChain.push({ 
            type: 'partner', 
            x: c.x, 
            center: c, 
            id: node.dataset.id 
        });
    });

    // C) Ordenamos por posici칩n X (Izquierda -> Derecha)
    visualChain.sort((a, b) => a.x - b.x);

    // 3. DIBUJAR LA L칈NEA BASE HORIZONTAL
    // Conectamos desde el primero de la izquierda hasta el 칰ltimo de la derecha
    const startX = visualChain[0].x;
    const endX = visualChain[visualChain.length - 1].x;
    
    layer.add(new Konva.Line({ 
        points: [startX, marriageY, endX, marriageY], 
        stroke: 'black', strokeWidth: 2 
    }));

    // Buscamos d칩nde qued칩 el paciente en la lista ordenada
    const patientIndex = visualChain.findIndex(n => n.type === 'patient');

    // 4. PROCESAR CADA NODO PARA S칈MBOLOS Y TALLOS
    visualChain.forEach((node, index) => {
        // A. Tallo Vertical (Bajada desde la persona a la l칤nea)
        layer.add(new Konva.Line({ 
            points: [node.x, node.center.y, node.x, marriageY], 
            stroke: 'black', strokeWidth: 2 
        }));

        // Si es el paciente, no lleva s칤mbolos de relaci칩n sobre s칤 mismo
        if (node.type === 'patient') return;

        // B. L칩gica de "El Vecino" (Neighbor) para calcular el centro del s칤mbolo
        // Si el nodo est치 a la izquierda del paciente, su "siguiente" es el de la derecha (index + 1)
        // Si el nodo est치 a la derecha del paciente, su "siguiente" es el de la izquierda (index - 1)
        let neighbor = null;

        if (index < patientIndex) {
            neighbor = visualChain[index + 1]; // Mira hacia la derecha (hacia el paciente)
        } else {
            neighbor = visualChain[index - 1]; // Mira hacia la izquierda (hacia el paciente)
        }

        // C. Calcular coordenadas del S칤mbolo
        // Exactamente en el medio entre este nodo y su vecino
        const midX = (node.x + neighbor.x) / 2;

        const pData = partners.find(p => p.id === node.id);
        if (pData) {
            const h = 8; 
            const symbolConfig = { stroke: 'black', strokeWidth: 2 };
            const tipo = pData.tipoRelacion;

            // Dibujar s칤mbolos (//, /, etc)
            if (tipo === 'separacion') {
                layer.add(new Konva.Line({ points: [midX - 4, marriageY + h, midX + 4, marriageY - h], ...symbolConfig }));
            } else if (tipo === 'divorcio') {
                layer.add(new Konva.Line({ points: [midX - 6, marriageY + h, midX - 2, marriageY - h], ...symbolConfig }));
                layer.add(new Konva.Line({ points: [midX + 2, marriageY + h, midX + 6, marriageY - h], ...symbolConfig }));
            } else if (tipo === 'reconciliacion') {
                layer.add(new Konva.Line({ points: [midX - 8, marriageY - h, midX + 8, marriageY + h], ...symbolConfig }));
            }

            // Tallo punteado si es "pareja de hecho"
            if (tipo === 'de_hecho') {
                 // Truco visual: pintamos l칤nea blanca encima y luego punteada negra
                 layer.add(new Konva.Line({ points: [node.x, node.center.y, node.x, marriageY], stroke: 'white', strokeWidth: 2 }));
                 layer.add(new Konva.Line({ points: [node.x, node.center.y, node.x, marriageY], stroke: 'black', strokeWidth: 2, dash: [10, 5] }));
            }

            // Detectar "pareja activa" para conectar hijos luego
            if (!activePartnerCenter && (tipo === 'normal' || tipo === 'de_hecho')) {
                activePartnerCenter = node.center;
            }
        }
    });
    
    // Fallback: Si todas son ex-parejas, usamos al paciente para que salgan los hijos
    // (Opcional, depende de tu l칩gica de negocio)
  }

  // ===============================================
  // 4) HIJOS (Sincronizado con la l칩gica de vecinos)
  // ===============================================
  if (patientDom && children.length > 0) {
    const cPatient = centerOf(patientDom);
    
    // Agrupar hijos
    const gruposHijos = {};
    gruposHijos['single'] = []; 
    partners.forEach(p => gruposHijos[p.id] = []); 

    children.forEach(child => {
       const pid = child.idPareja;
       if (pid && gruposHijos[pid]) gruposHijos[pid].push(child);
       else gruposHijos['single'].push(child);
    });

    Object.keys(gruposHijos).forEach(partnerId => {
        const misHijosData = gruposHijos[partnerId];
        if (misHijosData.length === 0) return;

        // A. Nodos visuales de los hijos
        const misHijosNodes = misHijosData.map(d => 
            hijosSlot.querySelector(`.persona[data-id="${d.id}"]`)
        ).filter(Boolean);
        
        if (misHijosNodes.length === 0) return;

        // B. Calcular ORIGEN del Tallo (startX)
        let startX, startY;
        
        if (partnerId === 'single') {
            startX = cPatient.x;
            startY = cPatient.bottom;
        } else {
            // Buscamos a la pareja
            const partnerNode = partnerLeftSlot.querySelector(`.persona[data-id="${partnerId}"]`) || 
                                partnerRightSlot.querySelector(`.persona[data-id="${partnerId}"]`);
            
            if (partnerNode) {
                const cPartner = centerOf(partnerNode);
                
                /* --- CORRECCI칍N L칍GICA DE VECINOS (Igual que en alinearGenograma) --- */
                // Para que la l칤nea baje EXACTAMENTE donde pusimos a los hijos
                let neighborX = cPatient.x; // Por defecto el vecino es el paciente

                if (partnerLeftSlot.contains(partnerNode)) {
                    // Si est치 a la izquierda, su vecino hacia el centro es el "siguiente"
                    const next = partnerNode.nextElementSibling;
                    if (next) neighborX = centerOf(next).x;
                } 
                else if (partnerRightSlot.contains(partnerNode)) {
                    // Si est치 a la derecha, su vecino hacia el centro es el "anterior"
                    const prev = partnerNode.previousElementSibling;
                    if (prev) neighborX = centerOf(prev).x;
                }

                // El tallo baja del promedio entre la PAREJA y su VECINO
                startX = (cPartner.x + neighborX) / 2;
                /* ------------------------------------------------------------- */

                startY = marriageY; 
            } else {
                startX = cPatient.x;
                startY = cPatient.bottom;
            }
        }

        // C. Calcular la Barra Horizontal
        const minChildTop = Math.min(...misHijosNodes.map(h => centerOf(h).top));
        // Altura de la barra
        const yEnd = startY + (minChildTop - startY) * 0.6; 

        // L칤mites de los hijos
        const allChildX = misHijosNodes.map(h => centerOf(h).x);
        let minBarX = Math.min(...allChildX);
        let maxBarX = Math.max(...allChildX);

        // Estiramiento de seguridad (Por si la f칤sica los movi칩 un poco extra)
        if (startX < minBarX) minBarX = startX;
        if (startX > maxBarX) maxBarX = startX;

        // D. Dibujar Tallo
        layer.add(new Konva.Line({ points: [startX, startY, startX, yEnd], stroke: 'black', strokeWidth: 2 }));

        // E. Dibujar Barra Horizontal
        layer.add(new Konva.Line({ points: [minBarX, yEnd, maxBarX, yEnd], stroke: 'black', strokeWidth: 2 }));

        // F. Bajadas individuales
        for (let i = 0; i < misHijosNodes.length; i++) {
            const hNode = misHijosNodes[i];
            const hData = misHijosData[i];
            const ch = centerOf(hNode);
            const tipo = hData.tipoHijo || 'biologico';

            // Gemelos
            let esParejaGemelos = false;
            if (i < misHijosNodes.length - 1) {
                const nextNode = misHijosNodes[i+1];
                const nextData = misHijosData[i+1];
                if (nextData && (tipo === 'mellizo' || tipo === 'gemelo') && (nextData.tipoHijo === tipo)) {
                    esParejaGemelos = true;
                    const chNext = centerOf(nextNode);
                    const midX = (ch.x + chNext.x) / 2;
                    
                    layer.add(new Konva.Line({ points: [midX, yEnd, ch.x, ch.top], stroke: 'black', strokeWidth: 2 }));
                    layer.add(new Konva.Line({ points: [midX, yEnd, chNext.x, chNext.top], stroke: 'black', strokeWidth: 2 }));
                    
                    if (tipo === 'gemelo') {
                         const barY = (yEnd + ch.top) / 2 + 5;
                         const x1 = midX + (ch.x - midX) * 0.5;
                         const x2 = midX + (chNext.x - midX) * 0.5;
                         layer.add(new Konva.Line({ points: [x1, barY, x2, barY], stroke: 'black', strokeWidth: 2 }));
                    }
                    i++; 
                    continue;
                }
            }
            
            // Normal
            if (!esParejaGemelos) {
                 const configLinea = { 
                    stroke: 'black', strokeWidth: 2,
                    dash: (tipo === 'adoptado') ? [5, 5] : [] 
                 };
                 layer.add(new Konva.Line({ points: [ch.x, yEnd, ch.x, ch.top], ...configLinea }));
            }
        }
    });
  }

  layer.draw();
}

/* ========== Eventos ========== */
agregarPacienteBtn.onclick = () => {
  const nombre = document.getElementById('nombre').value.trim();
  if (!nombre) return alert('Ingresa nombre');
  patient = { id:uid(), nombre, apellido:document.getElementById('apellido').value, edad:document.getElementById('edad').value, sexo:document.getElementById('sexo').value, esPaciente:true };
  formPaciente.style.display='none'; render();
};

function abrirMenu(x,y){ menu.style.left=x+'px'; menu.style.top=y+'px'; menu.classList.remove('oculto'); }
function cerrarMenu(){ menu.classList.add('oculto'); seleccionado=null; }
menuAgregarBtn.onclick = ()=>{ cerrarMenu(); abrirFormFamiliar(); };
menuEliminarBtn.onclick = ()=>{ if(seleccionado) eliminarSeleccionado(); cerrarMenu(); };

function abrirFormFamiliar(){ 
  formFamiliar.classList.remove('oculto'); 
  // Disparamos el evento change para configurar estados correctos al abrir
  famRolSelect.dispatchEvent(new Event('change'));
  actualizarCamposPorEstado();
}
function cerrarFormFamiliar(){ formFamiliar.classList.add('oculto'); }

/* --- C. BOT칍N GUARDAR (CORREGIDO) --- */
guardarFamiliarBtn.onclick = () => {
  // 1. CAPTURA DE TODOS LOS INPUTS (Incluyendo los nuevos de fechas)
  const nomInput = document.getElementById('famNombre');
  const apeInput = document.getElementById('famApellido');
  const edadInput = document.getElementById('famEdad');
  const sexoInput = document.getElementById('famSexo');
  const rolInput = document.getElementById('famRol');
  const estadoInput = document.getElementById('famEstado');
  const saludInput = document.getElementById('famSalud');
  const lgtbInput = document.getElementById('famLgtb');
  const tipoRelacionInput = document.getElementById('famTipoRelacion'); 
  const tipoHijoInput = document.getElementById('famTipoHijo');
  const idParejaInput = document.getElementById('famIdPareja'); // <--- NUEVO

  // --- NUEVO: Capturar los inputs de fecha aqu칤 arriba ---
  const anioInicioInput = document.getElementById('relAnioInicio');
  const anioFinInput = document.getElementById('relAnioFin');

  // Validaciones b치sicas
  const estado = estadoInput.value;
  const nom = nomInput.value.trim();
  const permiteSinNombre = ['embarazo', 'aborto_esp', 'aborto_prov'].includes(estado);
  
  if (!nom && !permiteSinNombre) return alert("Por favor ingresa un nombre");

  // Funci칩n auxiliar para limpiar el a침o (convierte texto a n칰mero o null)
  const getYearVal = (input) => {
    const val = parseInt(input.value.trim());
    // Si es un n칰mero v치lido y mayor a 1800, lo guardamos. Si no, null.
    return (Number.isFinite(val) && val > 1800) ? val : null;
  };

  // 2. CREACI칍N DEL OBJETO
  const p = { 
    id: uid(), 
    nombre: nom || '', 
    apellido: apeInput.value, 
    edad: edadInput.value, 
    sexo: sexoInput.value,
    estado: estado, 
    salud: saludInput.value,
    lgtb: lgtbInput.checked,
    tipoRelacion: tipoRelacionInput.value,
    tipoHijo: tipoHijoInput.value,
    idPareja: (rolInput.value === 'hijo') ? idParejaInput.value : null, // <--- NUEVO: Guardamos el ID de la pareja
    // Como ya definimos 'anioInicioInput' y 'getYearVal' arriba, esto ya no dar치 error
    relAnioInicio: (rolInput.value === 'pareja') ? getYearVal(anioInicioInput) : null,
    relAnioFin: (rolInput.value === 'pareja') ? getYearVal(anioFinInput) : null
  };

  // 3. LOGICA DE GUARDADO (Igual que antes)
  const rol = rolInput.value;
  if (rol === 'padre') { 
    if (p.sexo === 'M') parents.father = p; else parents.mother = p; 
  }
  else if(rol==='pareja') {
    // Si estamos editando uno existente, lo reemplazamos
    const idx = partners.findIndex(x => x.id === p.id);
    if (idx >= 0) partners[idx] = p;
    else partners.push(p); // Si es nuevo, lo a침adimos a la lista
  }
  else if (rol === 'hermano') siblings.push(p);
  else if (rol === 'hijo') children.push(p);
  
  // 4. RESETEAR FORMULARIO
  nomInput.value = ''; apeInput.value = ''; edadInput.value = '';
  estadoInput.value = 'vivo'; saludInput.value = 'ninguno';
  lgtbInput.checked = false;
  tipoRelacionInput.value = 'normal';
  tipoHijoInput.value = 'biologico';
  sexoInput.value = 'M'; rolInput.value = 'padre';
  
  // Resetear fechas tambi칠n
  anioInicioInput.value = '';
  anioFinInput.value = '';

  cerrarFormFamiliar(); 
  render();
};

function eliminarSeleccionado(){
  const id = seleccionado.id;
  if(patient && patient.id===id) { patient=null; formPaciente.style.display='block'; }
  if(parents.father && parents.father.id===id) parents.father=null;
  if(parents.mother && parents.mother.id===id) parents.mother=null;
  partners = partners.filter(p => p.id !== id);
  siblings = siblings.filter(s=>s.id!==id);
  children = children.filter(c=>c.id!==id);
  render();
}

window.addEventListener('resize', () => {
  if (stage) { stage.destroy(); stage=null; layer=null; }
  alinearGenograma();
  requestAnimationFrame(() => dibujarConexiones());
});

const params = new URLSearchParams(window.location.search);
if(params.has('nombre')){
   patient = { id:uid(), nombre:params.get('nombre'), apellido:params.get('apellido')||'', edad:params.get('edad')||0, sexo:params.get('sexo')||'M', esPaciente:true };
   formPaciente.style.display='none';
}

render();
</script>
</body>
</html>